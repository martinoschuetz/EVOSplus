      BLOCK DATA
C
C DATENBANK: ZONAL GEMITTELTE KLIMADATEN FUER BEIDE HAEMISPHAEREN
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (NX = 33, L = 2*9)
C
      CHARACTER *7 NAME(NX)
      DOUBLE PRECISION LP1
C
      COMMON/TRANS/YALT(NX),DELTA(NX)
      COMMON/NAMELIST/NAME
      COMMON/EXPE/TO1(L),TA1(L),TS1(L),Q1(L),EVA1(L),P1(L),RH1(L),
     +FOZ(L),FAT(L),FLUSSQ1(L),BEW1(L),AP1(L),RO1(L),HU1(L),
     +RA1(L),LP1(L),ABSA1(L),ABSO1(L),XA1(L),XO1(L),FL1(L),PHI(L)
C
      DATA NAME/'VA=','VQ=','DA=','DQ(1)=','DQ(2)=','DW(1)=','DW(2)=',
     +'PC(1)=','PC(2)=','LAM(1)=','LAM(2)=','RMIN=','RCRIT=',
     +'UNTEN=','THICK=','WOLK1=','WOLK2=','TOP=','UPPER=',
     +'GAM=','CO2=','ALF1=','ALF2=','KAP1=','EISBED=','RSURF=','DICE=',
     +'SONNE=','HADKOF=','BETA=','W0=','ALBL=','LAPS=' /
C
      DATA TA1/-25.50,-16.75,-6.80,2.08,9.85,16.45,22.15,24.45,26.00,
     +26.55,26.15,23.00,16.75,9.20,2.25,-4.65,-11.65,-16.31/
      DATA TO1/0.00,0.00,0.00,3.33,10.01,17.66,22.68,25.75,27.03,
     +27.70,26.88,24.19,19.49,11.35,6.95,4.43,0.50,0.00/
      DATA Q1/0.2,0.9,2.7,4.1,6.4,9.2,12.4,15.4,17.2,
     +17.9,16.9,13.9,10.4,6.8,4.8,3.3,2.1,0.9/
      DATA P1/0.070,0.228,0.548,1.200,1.260,0.932,0.740,1.050,
     +1.490,1.965,1.139,0.700,0.770,0.825,0.761,0.464,0.240,0.15/
      DATA EVA1/0.0,0.045,0.174,0.52,0.895,1.256,1.416,1.541,1.304,
     +1.235,1.389,1.246,1.002,0.64,0.47,0.333,0.145,0.042/
C     DATA BEW1/0.47,0.56,0.77,0.79,0.65,0.54,0.47,0.47,0.50,
C    +0.51,0.44,0.41,0.47,0.57,0.64,0.64,0.61,0.55/
      DATA BEW1/0.47,0.58,0.83,0.80,0.70,0.59,0.52,0.53,0.58,
     +0.60,0.53,0.47,0.57,0.63,0.71,0.69,0.68,0.70/
      DATA AP1/0.62,0.60,0.51,0.43,0.36,0.30,0.25,0.24,0.24,
     +0.25,0.25,0.27,0.31,0.36,0.41,0.45,0.54,0.59/
      DATA LP1/156.,170.,188.,193.,211.,229.,238.,247.,247,
     +252.,247.,238.,223.,215.,206.,192.,178.,178./
C     DATA FL1/-0.25,-0.95,-2.3,-3.85,-5.0,-5.4,-4.8,-3.35,-1.05,
C    +1.60,3.90,5.25,5.5,5.0,3.9,2.45,1.1,0.17/
      DATA FL1/-0.25,-0.99,-2.31,-4.30,-5.63,-6.12,-5.63,-4.30,-1.99,
     +1.16,3.48,4.63,4.97,4.63,3.48,1.99,0.83,0.17/
      DATA FAT/-0.08,-0.16,-0.41,-1.82,-2.98,-3.15,-2.15,-1.49,-0.33,
     +0.66,1.24,1.74,2.48,2.98,2.81,1.66,0.67,0.16/
C     DATA FOZ/-0.07,-0.60,-1.55,-2.10,-2.25,-2.3,-2.45,-2.15,-0.65,
C    +1.1,2.7,3.55,3.05,2.1,1.3,0.75,0.35,0.0/
      DATA FOZ/-0.07,-0.60,-1.82,-2.48,-2.65,-3.14,-3.48,-3.14,-1.66,
     +0.53,1.99,2.81,2.48,1.82,0.83,0.33,0.17,0.0/
      DATA HU1/5.0,4.5,4.0,4.0,4.3,4.1,4.0,4.3,5.3,
     +5.9,5.0,4.2,5.0,4.7,4.5,4.1,3.1,3.5/
      DATA PHI/-85.,-75.,-65.,-55.,-45.,-35.,-25.,-15.,-5.,
     +5.,15.,25.,35.,45.,55.,65.,75.,85./
      END
C     VERSION VOM 26.2.94
C     VERSION VOM 29.4.94
C     VERSION VOM 15.4.94
C     VERSION VOM 12.3.94
C     VERSION VOM 20.5.94
C     VERSION VOM 2.6.94
C     VERSION VOM 1.7.94
C     VERSION VOM 20.8.94
C     VERSION VOM 31.8.94
C     VERSION VOM 2.9.94
C     VERSION VOM 15.6.95
C
C
C      PROGRAM OPT
      SUBROUTINE JENTSCH (NXPJ,XPJ,ZIFU,STARTE,FALL)
C
C     VERFAHREN MIT IMSL-ROUTINE DBCLSJ (LEVENBERG-MARQUARDT)
C*
C***************************************************************************
C*
C*    NONLINEAR INVERSE PROBLEM FORMULATED AS AN OPTIMIZATION PROBLEM:
C*    MINIMIZE
C*    G(X(P)), SUBJECT TO F(X(P),P)=0 AND -1 < P < +1
C*    HERE X IS THE VECTOR OF DIMENSION MM=3*M CONSISTING OF RH,TA,TS
C*    (IN NORMALIZED FORM), P IS THE PARAMETER VECTOR OF DIMENSION NX.
C*    THE PROBLEM IS SOLVED BY MEANS OF IMSL ROUTINE DBCLSJ.
C*    FOR A GIVEN VECTOR P WE SOLVE THE SET OF NONLINEAR EQUATIONS BY A
C*    NEWTON METHOD (SUBR. NEWTON AND JAKFKT). THE SOLUTION IS CALLED X.
C*    THIS VECTOR OF LENGTH MM IS INSERTED INTO THE TARGET FUNCTION G
C*    OF SUBR. "OBJFUN".
C*    THE GRADIENT OF THE TARGET FUNCTION IS COMPUTED IN SUBR. "OBJGRD". THE
C*    PROCEDURE IS AS FOLLOWS. INCREMENT VECTOR P, COMPUTE THE CORRESPONDING
C*    SOLUTION XNEW, OBEYING F(X(P),P)=0 AT X=XNEW, P=PNEW
C*    AND INSERT INTO G, GIVING GNEW. THE GRADIENT IS THEN (GNEW-G)/(PNEW-P).
C*    THE FACT THAT THE JACOBIAN OF THE UNDERLYING SYSTEM
C:    OF NONLINEAR EQUATIONS IS BANDED, IS ESSENTIAL, AS IT SAVES TIME!
C*
C*  GLOBAL PARAMETERS:
C*    M      NUMBER OF GRID POINTS PER DEPENDENT VARIABLE (RH,TA,TS)
C*    MM     NUMBER OF EQUATIONS = NUMBER OF DEGREES OF FREEDOM
C*    ML     NUMBER OF LOWER CODIAGONALS
C*    MU     NUMBER OF UPPER CODIAGONALS
C*    NX     MAXIMUM NUMBER OF PARAMETERS
C*    N      NUMBER OF PARAMETERS ACTUALLY UNDER CONSIDERATION, N < NX
C*    INTV   STEPSIZE FOR EACH OPTIMIZATION-ITERATION
C*    NOBJ   NUMBER OF LEAST SQUARE FACTORS (=GLIED) IN THE OBJECT FUNCTION
C*
C*  VARIABLES:
C*    KMAX    MAX NUMBER FOR NEWTON-ITERAIONS
C*    PARNR   SELECTS N PARAMETERS OUT OF NX
C*    XSTART  STARTING VALUES FOR RH,TA,TS IN NORMALIZED FORM
C*    X()     ITERATED XSTART
C*    Y()     RIGHT HAND SIDE OF THE DIFFERENTIAL EQUATIONS Y=F(X(P),P)
C*    PSTART  NX START PARAMETERS IN NORMALIZED FORM, USUALLY ALL ZERO
C*    PP()    NX PARAMETERS IN NORMALIZED FORM
C*    P()     N PARAMETERS IN NORMALIZED FORM
C+    PNEU()  N PARAMETERS IN NORMALIZED FORM, FINAL RESULT
C*    PASTART NX PARAMETERS IN PHYSICAL SPACE, START VALUES
C*    PARAM   NX PARAMETERS IN PHYSICAL SPACE, RESULTING VALUES
C+    GLIED() FINAL VALUES OF LEAST SQUARE FACTORS AFTER EACH ITERATION
C*    KLICK   DECIDES WHETHER OPTIMIZATION OR SIMPLY SENSITIVITY STUDY
C*    KLICK=TRUE: OPTIMIZATION PLUS SENSITIVITY
C*    KLICK=FALSE: SENSITIVITY ONLY
C
C*
C*  ROUTINES:
C*    INIT    MACHINE CONSTANTS
C*    EINGABE CONSTANTS, FUNCTIONS AND INITIAL VALUES
C*    EINGAB1 INPUT DATA FROM TAPE
C*    AUSGABE OUTPUT OF RESULTS
C*    NEWTON  SOLUTION METHOD FOR THE SYSTEM OF NONLINEAR EQ.
C*    WOLF    CALLS FCN WHICH COMPUTES THE RIGHT HAND SIDE
C*            OF THE DISCRETIZED EQUATIONS
C*    OBJFUN  OBJECT FUNCTION, AS DEMANDED BY IMSL DBCLSJ; CALLS FUNCT
C*    FUNCT   DEFINITION OF THE OBJECT FUNCTION
C:    JAC     JACOBIAN DG/DP OF THE OBJECT FUNCTION
C*    JAKFKT  JACOBIAN DY/DX OF THE NONLINEAR SYSTEM
C*
C*    LINPACK-ROUTINES
C*    DCOPY
C*    DNRM2
C*    DGBFA
C*    DQRDC
C*
C****************************************************************************
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 XPJ(24),ZIFU,STARTE,FALL
C
      PARAMETER (M = 180, MM = 3*M, ML = 4, MU = 4, LDA = 2*ML+MU+1,
     + N = 24, NX = 33, NOBJ = 11*18+25, LDFJAC = NOBJ, IBTYPE = 0)
C
      CHARACTER *7 NAME(NX)
      INTEGER    PARNR(N), IPVT(MM), IPARAM(6)
      DOUBLE PRECISION RH1(M), RH(M), TA(M), TS(M)
     +           ,OBJF, DXTOL, DYTOL, RES, DNRM2, GLIED(NOBJ)
     +           ,BL(N), BU(N), XSTART(MM), X(MM), Y(MM), PASTART(NX)
     +           ,ABD(LDA,MM), PP(NX), PSTART(NX), P(N), PNEU(N)
     +           ,PSCALE(N), FSCALE(NOBJ), RPARAM(7), FJAC(LDFJAC,N)
      LOGICAL    KLICK
C
      COMMON/GLOBDAT/ABD, X, Y, IPVT, XSTART
      COMMON/GLOBTOL/DXTOL, DYTOL, KMAX
      COMMON/GLOBPAR/ PP, PSTART, PARNR, IZAHL
      COMMON/BL5/RH,TA,TS,DUMMY(2*M),RH1
      COMMON/COEFFI/PARAM(NX)
      COMMON/GLOBNFC/NFCALL
      COMMON/NAMELIST/NAME
      DATA PSCALE/N*1.D0/,FSCALE/NOBJ*1.D0/
      DATA BL,BU/N*-1.0D0,N*1.0D0/
C
C      WRITE(*,108)
C  108 FORMAT(' KLICK = F(KEINE OPTIMIERUNG) ODER T( OPTIMIERUNG)')
C      READ(*,109) KLICK
C  109 FORMAT(L1)
C      IF(KLICK) THEN
C      WRITE(*,110)
C      READ(*,*) IZAHL
C  110 FORMAT(' ANZAHL DER ITERATIONEN=')
C      END IF
      FALL=0.
      IPARAM(1)=0
      IF(STARTE.GT.0.) GOTO 3333
      CALL INIT
C**************************************************
      DO 1 I = 1,N
  1   PARNR(I) = I
C
C     SELECTION OF PARAMETERS 1,.,N (N<=NX) TO BE OPTIMIZIED
      PARNR( 4)=33
      PARNR( 6)=26
      PARNR( 12)=31
      PARNR( 13)=29
C     PARNR( 16)=32
      PARNR( 17)=32
      PARNR( 19)=30
C
C
C***************************************************
C     BERECHNUNG DER ZIELFKT. OBJF FUER STARTWETRE PSTART, XSTART
      CALL EINGABE (PSTART,XSTART)
      CALL DCOPY (NX,PARAM,1,PASTART,1)
      CALL DCOPY (NX,PSTART,1,PP,1)
      CALL DCOPY (MM,XSTART,1,X,1)
C
C     SELECTION OF PARAMETERS TO BE VARIED
      DO 2 I = 1,N
   2     P(I) = PP(PARNR(I))
C
C
C      CALL NEWTON (ABD,LDA,ML,MU,IPVT,DXTOL,DYTOL,X,Y,PP,
C     +                1,IERR,K,KMAX,FALL)
C      IF (IERR.GT.0) THEN
C         WRITE(6,1000) IERR,K
C 1000    FORMAT(' ERR-NR ',I1,' IN NEWTON  K = ',I3)
C         STOP 'STOP 1'
C      END IF
C
C
C      CALL FUNCT (PP,X,OBJF,GLIED)
C
C      RES = DNRM2 (MM,Y,1)
C      WRITE(66,101)
C      WRITE(66,102) K,RES
C      WRITE(6,1010) OBJF
C
C
C     IF (.NOT.KLICK) GO TO 30
C     NO OPTIMISATION (GO TO 30)
C
C     START OPTIMIZING
C     CALL DU4LSF, IF NON-DEFAULT VALUES FOR IPARAM, RPARAM ARE DESIRED
C     CALL DU4LSF(IPARAM,RPARAM)
C     SET VALUES NOW
          IPARAM(3)=500
          IPARAM(4)=1000
          IPARAM(5)=1000
          RPARAM(1)=1.D-06
          RPARAM(2)=1.D-06
          RPARAM(3)=1.D-06
          RPARAM(4)=1.D-06
          RPARAM(5)=1.D-06
C
C         CALL DBCLSJ (OBJFUN, JAC, NOBJ, N, P, IBTYPE, BL, BU, PSCALE,
C     +           FSCALE, IPARAM, RPARAM, PNEU, GLIED, FJAC, LDFJAC)
C
C         WRITE(*,132) RPARAM
C         WRITE(*,133) IPARAM
C  132    FORMAT(' RPARAM',7E10.2)
C  133    FORMAT(' IPARAM',7I8)
C
CC      WRITE(66,11011) NOBJ
CC      WRITE(66,11012) N
CC      WRITE(66,11103) P
CC      WRITE(66,11104) GLIED
CC      WRITE(66,11013) FALL
CC      WRITE(66,11014) ZIFU
      CALL OBJFUN(NOBJ,N,P,GLIED,FALL,ZIFU)
      STARTE = 1.
C     CALL PUT(8HSTARTE  ,1,1,1.0,1.0,IT,ITM,ATM,LOBC)
      ZIFU=FALL*100000. + ZIFU
C      OBJF=ZIFU
C      WRITE(66,1010) ZIFU
CC     WRITE(66,1020) M
CC      WRITE(66,1030) (I,NAME(I),PARAM(I),I=1,NX)
CC     WRITE(66,557) RH
CC      WRITE(66,557) TA
CC      WRITE(66,557) TS
      RETURN
3333  DO 3334 I=1,N
      PNEU(I)=DBLE(XPJ(I))
3334  CONTINUE
C
C        INSERTING PNEU INTO COMPLETE PARAMETER VECTOR PP
      DO 15 I = 1,N
            P(I) = PNEU(I)
  15        PP(PARNR(I)) = P(I)
CC      WRITE(66,11011) NOBJ
CC      WRITE(66,11012) N
CC      WRITE(66,11103) P
CC      WRITE(66,11104) GLIED
CC      WRITE(66,11013) FALL
CC      WRITE(66,11014) ZIFU
CC11011 FORMAT(' NOBJ : ',I4)
CC11012 FORMAT(' N : ',I4)
CC11103 FORMAT(/' P'/5(D12.5))
CC11104 FORMAT(/' GLIED'/5(D12.5))
CC11013 FORMAT(' FALL : ',I4)
CC11014 FORMAT(' ZIFU : ',D12.5)
      CALL OBJFUN(NOBJ,N,P,GLIED,FALL,ZIFU)
      ZIFU=FALL*100000. + ZIFU
      RETURN
C
C     COMPUTATION OF OBJECTIVE FUNCTION
C      CALL FUNCT (PP,X,OBJF,GLIED)
C
C      WRITE(66,103) PP
C      WRITE(66,1012) (NAME(I),PASTART(I),PARAM(I),I=1,NX)
C      WRITE(66,1011) NFCALL
C      WRITE(66,1010) ZIFU
C      DO 3 J=1,N
C      WRITE(66,560) J
C  3   WRITE(66,559) (FJAC(I,J),I=1,NOBJ)
C
C     DARSTELLUNG DER STARTWERTE FUER WEITERE VERWENDUNG
C 30   CONTINUE
C      WRITE(66,555)
CC      WRITE(66,1020) M
CC      WRITE(66,1030) (I,NAME(I),PARAM(I),I=1,NX)
CC      WRITE(66,557) RH
CC      WRITE(66,557) TA
CC      WRITE(66,557) TS
C      WRITE(66,555)
C
C      RETURN
C
C     CALL AUSGABE
C
C     CALL MONITOR
C
C
  100 FORMAT(' PP'/5(D12.5))
  101 FORMAT(' BEGINN')
  102 FORMAT(' NR DER NEWTON-ITERATION:',I3,'      RESIDUUM ', D11.3)
  103 FORMAT(/' ENDERGEBNIS PP'/5(D12.5))
  555 FORMAT(' INFORMATION')
  557 FORMAT(3E19.12)
  559 FORMAT(9D9.2)
  560 FORMAT(' JAKOBIMATRIX PARAMETERNUMBER=',I3/)
 1010 FORMAT(' WERT DER ZIELFUNKTION : ',D19.12/)
 1011 FORMAT(' ANZAHL DER ZIELFKTSAUSWERTUNGEN : ',I4)
 1012 FORMAT(2(1X,A7,E12.5,2X,E12.5))
 1040 FORMAT(3E19.12)
 1020 FORMAT('M = ',I4)
 1030 FORMAT(I2,1X,A7,2X,E19.12)
 1070 FORMAT(' GESAMTRESIDUUM:',E19.12)
C      STOP 'OPTIMSL OK'
      END
C
C*****************************************************************************
      SUBROUTINE INIT
C
C*    FIXES MACHINE DEPENDENT CONSTANTS AND INITIALIZES CERTAIN INDICES
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (M = 180, MM = 3*M)
C
      COMMON/GLOBKON/DMCHEPS, DEPS3, DEPSROT, DEPSQAD
      COMMON/GLOBTOL/DXTOL, DYTOL, KMAX
      COMMON/GLOBNFC/NFCALL
C
      NFCALL = 0
C
      DEPS = 1.0D0
      DX = 2.0D0
      DY = 1.0D0
  30  IF (DX.EQ.DY) GO TO 40
         DEPS = DEPS*0.5D0
         DX = 1.0D0+DEPS
      GO TO 30
  40  DMCHEPS = 2.0D0*DEPS
      DEPSROT = DSQRT(DMCHEPS)
      DEPS3 = DMCHEPS**(1.0D0/3.0D0)
      DEPSQAD = DMCHEPS*DMCHEPS
C
      DXTOL = 1.0D-10
      DYTOL = 1.0D-9 * (M/180.0D0)
      KMAX  = 25
C
C      WRITE(66,1000) DMCHEPS,DEPSROT,DEPSQAD,
C     +              DXTOL, DYTOL, KMAX
C
 1000 FORMAT(' DMACHEPS = ',D11.4/
     +       ' DEPSROOT = ',D11.4/' DEPSQUAD = ',D11.4/
     +       ' DXTOL    = ',E11.4/' DYTOL    = ',E11.4/
     +       ' KMAX     = ',I6)
C
      RETURN
      END
C
C*****************************************************************************
C
      SUBROUTINE OBJFUN (NOBJ, NP, P, GLIED, FALL, ZIFU)
C
C*    OBJECT FUNCTION, AS REQUIRED BY IMSL-ROUTINE DBCLSJ
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL,ZIFU
      PARAMETER (M = 180, MM = 3*M, ML = 4, MU = 4, LDA = 2*ML+MU+1,
     +           NX = 33,N = 24)
C
      CHARACTER *7 NAME(NX)
C
      DOUBLE PRECISION PSTART(NX), P(NP), GLIED(NOBJ), RH(M), TA(M),
     +TS(M), X(MM), Y(MM), XSTART(MM), PP(NX), ABD(LDA,MM)
      INTEGER IPVT(MM), PARNR(N)
C
      COMMON/BL5/RH,TA,TS,DUMMY(2*M),RH1(M)
      COMMON/GLOBKON/DMCHEPS, DEPS3, DEPSROT, DEPSQAD
      COMMON/GLOBDAT/ABD, X, Y, IPVT, XSTART
      COMMON/GLOBTOL/DXTOL, DYTOL, KMAX
      COMMON/GLOBPAR/ PP, PSTART, PARNR, IZ
      COMMON/COEFFI/YPAR(NX)
      COMMON/NAMELIST/NAME
      COMMON/DRUCK/TO(M),TSTR(M),TASTR(M),EISL(2),BEW(M),ABSORB(M),
     +EMIT(M),HADLEY(2),H(M),ALAT(M),OLAT(M),SNOW(2),
     +AFLUX(M),QFLUX(M),OFLUX(M),PCRIT(M),
     +RA(M),RO(M),EVA(M),PTOTAL(M),QSTR(M),GRAT(M),GRATQ(M)
C
      DATA IZAHL/1/
C
      DO 5 I = 1,N
   5     PP(PARNR(I)) = P(I)
C
      CALL NEWTON (ABD,LDA,ML,MU,IPVT,DXTOL,DYTOL,X,Y,PP,
     +             1,IERR,K,KMAX,FALL)
C
C
      IF (IERR.GT.0) THEN
C         WRITE(6,1010) IERR,K
C 1010    FORMAT(' ERR-NR ',I1,' IN NEWTON  K =',I4)
C         WRITE(6,100) (I,NAME(I),YPAR(I),I=1,NX)
C         STOP 'STOP 2'
	 FALL=2.
	 RETURN
      END IF
C
C     COMPUTE OBJECT FUNCTION
      CALL FUNCT (PP,X,OBJF,GLIED)
      ZIFU=SNGL(OBJF)
C
C      WRITE(*,101) IZAHL, OBJF, YPAR(9), YPAR(12)
C  101 FORMAT(' NR=',I3,' OBJ=',D10.4,' PC(2)=',F6.4,
C     +        ' RMIN=',F6.3)
C      WRITE(66,100) (I,NAME(I),YPAR(I),I=1,NX)
C      WRITE(66,102)
C      WRITE(66,100) (I,NAME(I),PP(I),I=1,NX)
C      WRITE(66,102)
C      WRITE(66,102)
C
C     DIE OPTIMIERUNG WIRD NACH IZ ITERATIONEN ABGEBROCHEN, ERGEBNISSE
C     WERDEN AUSGEDRUCKT. WENN IZ GROSS (100 ODER MEHR), SOLLTE DIESE ABFRAGE NICHT
C     GREIFEN, DA DIE ROUTINE DANN ERFOLGREICH SEIN MUESSTE.
C
C      IF(IZAHL.EQ.IZ) THEN
C      WRITE(66,102) IZAHL
C      WRITE(66,100) (I,NAME(I),PP(I),I=1,NX)
C      WRITE(66,102)  IZAHL
C      WRITE(66,1020) M
C      WRITE(66,100) (I,NAME(I),YPAR(I),I=1,NX)
C      WRITE(66,557) RH
C      WRITE(66,557) TA
C      WRITE(66,557) TS
C      CALL AUSGABE
C      STOP
C      END IF
  100 FORMAT(I2,1X,A7,2X,E19.12)
  102 FORMAT(/' IZAHL=',I3)
  557 FORMAT(3E19.12)
 1020 FORMAT('M = ',I4)
C
      IZAHL = IZAHL+1
      RETURN
      END
C ===
C
      SUBROUTINE EINGAB1 (PP,X)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (M = 180, MM = 3*M, NX = 33, NTAPE = 3)
C     PP() PARAMETERS IN PHYSICAL SPACE
C
      DOUBLE PRECISION  PP(NX), X(MM)
      CHARACTER*5 TEXT
      CHARACTER*7 NAME(NX)
      LOGICAL    FOUND
C
      COMMON/COEFFI/PANF(NX)
      COMMON/NAMELIST/NAME
C
      OPEN(NTAPE,FILE='clima.dat')
      OPEN(66,FILE='OUTPUT.DAT')
C      OPEN(67,FILE='KAI.DAT')
C
      FOUND = .FALSE.
C     SUCHE NACH DATENSATZ MIT GLEICHER AUFLOESUNG
   1  READ(NTAPE,1020,END=3) TEXT,L
      IF (L.EQ.20) THEN
         LJ = L+1
      ELSE
         LJ = L
      END IF
      IF (L.EQ.M) THEN
         READ(NTAPE,1000) (J,NAME(I),PP(I),I=1,NX)
         READ(NTAPE,1010) X
         FOUND = .TRUE.
C         WRITE(6,1040)
      ELSE
         DO 32 J = 1,LJ+NX
   32       READ(NTAPE,*)
         GO TO 1
      END IF
      IF (.NOT.FOUND) STOP 'NOT FOUND'
C
 1000 FORMAT(I2,1X,A7,2X,E19.12)
 1010 FORMAT(3E19.12)
 1020 FORMAT(A4,I4)
 1040 FORMAT(' STARTWERT MIT GLEICHER PUNKTZAHL GEFUNDEN!')
C
      CALL DCOPY (NX,PP,1,PANF,1)
      RETURN
    3 STOP 'END OF INPUT'
      END
C ===
C
      SUBROUTINE JAKFKT (A,LDA,ML,MU,X,Y,P,N,INF,FALL)
C
C     COMPUTES THE JACOBIAN OF THE SYSTEM OF NONLINEAR EQUATIONS
C     BANDED STRUCTURE
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL
      PARAMETER (M = 180, MM = 3*M)
      DOUBLE PRECISION  X(MM), Y(MM), P(N), YR(MM), XH(MM), A(LDA,MM)
C
C
      COMMON/GLOBKON/DMCHEPS, DEPS3, DEPSROT, DEPSQAD
C
      IF (INF.EQ.1) CALL WOLF(P,X,Y,FALL)
C
      IBAND = MU+ML+1
      DO 10 I=1,MM
   10    XH(I) = DEPSROT
      DO 40 I=1,IBAND
         DO 50 J=I,MM,IBAND
   50       X(J) = X(J)+XH(J)
C        CALL WOLF (P,X,YR,FALL)
         CALL FCN (X,YR,FALL)
         DO 60 J=I,MM,IBAND
            X(J) = X(J)-XH(J)
            M1 = MAX0(1,J-MU)
            M2 = MIN0(MM,J+ML)
            H = 1.0D0/XH(J)
            DO 70 K=M1,M2
   70          A(K-J+IBAND,J) = (YR(K)-Y(K))*H
   60    CONTINUE
   40 CONTINUE
C
      RETURN
      END
C ===
      SUBROUTINE NEWTON (ABD, LDA, ML, MU, IPVT, DXTOL, RESTOL, X, Y,
     +                   PP, INF, IERR, K, KMAX, FALL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL
C
      PARAMETER (M = 180, MM = 3*M, NX = 33)
      PARAMETER (RESFAK=1.05, GAMMIN = 1.0D-6)
C
      INTEGER    IPVT(MM)
      DOUBLE PRECISION   X(MM), Y(MM), PP(NX), YH(MM), XH(MM),
     +                   ABD(LDA,MM)
      LOGICAL    FLAG
C
      COMMON/GLOBKON/DMCHEPS, DEPS3, DEPSROT, DEPSQAD
      COMMON/GLOBCNT/GLCOUNT, SLCOUNT
C     LOEST (HOFFENTLICH) DIE NICHTLINEAREN GLEICHUNGEN
C     PROBLEM BEI DIESEM VERFAHREN: GELEGENTLICH KONVERGIERT ES NICHT.
C     WARUM?
      K = 0
      IERR = 0
      CALL WOLF (PP,X,Y,FALL)
      RES = DNRM2 (MM,Y,1)
C
      IF ((RES.LT.RESTOL).OR.(K.GE.KMAX)) RETURN
C
    5 IF (INF.GT.0) THEN
         CALL JAKFKT (ABD,LDA,ML,MU,X,Y,PP,NX,1,FALL)
         CALL DGBFA (ABD,LDA,MM,ML,MU,IPVT,INFO)
           IF(INFO.NE.0) THEN
C           WRITE(*,111) INFO
C 111       FORMAT(' INFO',I3)
C           STOP 'STOP 5'
         FALL=5.
         RETURN
           END IF
         GLCOUNT = GLCOUNT+1
      END IF
C
      CALL DGBSL (ABD,LDA,MM,ML,MU,IPVT,Y,0)
      SLCOUNT = SLCOUNT+1
C
      CALL DCOPY (MM,Y,1,YH,1)
      GAMMA = 1.0D0
      RESALT = RES
 100  CONTINUE
C
C        NEWTONSCHRITT DARF HOECHSTENS SO LANG SEIN, DASS DIE FEUCHTE
C        NICHT NEGATIV WIRD UND AUCH NICHT ZU GROSS WIRD
      DO 20 I = 1,MM,3
            IF ((X(I)-YH(I)).LT. -3.0)
     +         GAMMA = DMIN1(GAMMA,DABS((1.0+X(I))/YH(I)))
            IF ((X(I)-YH(I)).GT.1.0)
     +         GAMMA = DMIN1(GAMMA,DABS((1.0-X(I))/YH(I)))
  20     CONTINUE
      GAMMA = (1.0D0-DEPSROT)*GAMMA
      DX = DNRM2 (MM,YH,1)
C
  30  DO 40 I = 1,MM
  40        XH(I) = X(I)-GAMMA*YH(I)
      CALL FCN(XH,Y,FALL)
      RES = DNRM2 (MM,Y,1)
      GAMMA = GAMMA*0.5
      IF(RES.GE.(RESFAK*RESALT) .AND. (GAMMA.GE.GAMMIN)) GO TO 30
      GAMMA = 2.0*GAMMA
      CALL DCOPY (MM,XH,1,X,1)
      RES = DNRM2 (MM,Y,1)
C
C125  FORMAT(E10.3)
C
      DX=GAMMA*DX
      K=K+1
      FLAG = (RES.GT.RESTOL).OR.(DX.GT.DXTOL)
      IF (FLAG.AND.K.LT.KMAX) GO TO 5
C
      IF (FLAG.AND.(K.GE.KMAX)) THEN
            IERR = 1
C            WRITE(66,1000) K,RES,DX,GAMMA,INFO,INF
C 1000       FORMAT(1I4,3E10.3,2I4)
C            WRITE(66,1001) PP
C 1001       FORMAT(1X,E19.12)
C            DO 50 I=1,MM,3
C            IF(X(I).LT.-3.0D0) THEN
C            WRITE(66,1002) I,X(I)
C 1002       FORMAT(' NEWTONITERATION =',I3,' X=',D12.4)
C            GO TO 51
C            END IF
C   50       CONTINUE
C   51       CONTINUE
      END IF
C
      RETURN
      END
C ===
C
      SUBROUTINE FUNCT(XC,YVEC,FC,GLIED)
C     PROGRAMM NAME IN DER IMSL-BIBLIOTHEK: OBJFUNCT
C
C     COMPUTATION OF OBJECT FUNCTION FC, WEIGHT G,
C     VARIABLES WITH SUBSCRIPT "1" ARE DATA (TOTAL NUMBER L),
C     VARIABLES WITH SUBSCRIPT "X"
C     ARE NUMERICAL RESULTS ADJUSTED TO LATITUDES OF MEASUREMENTS
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(NX = 33,M = 180,MM = 3*M, MK=6*M, L=2*9, LL=11*L,
     +          NOBJ=LL+25)
C
      DOUBLE PRECISION LP1,LA1,LO1,LP,LO,LA,LPX
      DIMENSION XC(NX),FL(M),G(6),AP(M),YVEC(MM),J2(L),SZC(L)
     +,F1(13), GLIED(NOBJ), HUX(L), HLX(L)
C
      COMMON/BL1/ALF2,SOLEIL(M),EISFREI(M),EISF(M),SONNE,TROPOS(M)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),FI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL5/RH(M),TA0(M),TS0(M),TAE(M),TSE(M),RHE(M)
      COMMON/BL10/ DU(8),HL(M),HU(M),DU1(2*M+3)
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CL,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
      COMMON/DRUCK/TO(M),TS(M),TA(M),EISL(2),BEW(M),ABSORB(M),
     +LP(M),HADLEY(2),H(M),ALAT(M),OLAT(M),SNOW(2),
     +AFLUX(M),QFLUX(M),OFLUX(M),PCRIT(M),
     +RA(M),RO(M),EVA(M),P(M),Q(M),GRAT(M),GRADQ(M)
      COMMON/DRUCKX/TAX(L),TOX(L),QX(L),BEX(L),APX(L),PX(L),
     +EVX(L),FLX(L),LPX(L),FAX(L),FOX(L),FQX(L),HUX
      COMMON/EXPE/TO1(L),TA1(L),TS1(L),Q1(L),EVA1(L),P1(L),RH1(L),
     +FLUSSO1(L),FLUSSA1(L),FLUSSQ1(L),BEW1(L),AP1(L),RO1(L),HU1(L),
     +RA1(L),LP1(L),ABSA1(L),ABSO1(L),LA1(L),LO1(L),FLUSSG1(L),PHI(L)
      COMMON/AUSG/GLIEDER(M,13),GHA,GAP,GP,GTA,GTAU,GQ,QUOT,GHL,GHU,F1,
     +            GBEW
      COMMON/AUSG1/DUMM(6*M),FLUSSA(M),FLUSSO(M),FLUSSQ(M)
      COMMON/AUSG2/AMDA(M),LO(M),LA(M),ABSO(M),ABSA(M),
     +             ALBL(M),ALBH2O(M),ALBW(M)
C
      COMMON/AUSG4/CQUOT(M),TAU(M),CONTR(5*M),APPA(M),W(M)
      COMMON/GLOBNFC/NFCALL
      COMMON/COEFFI/Y(NX)
      SAVE
C
      DATA G/ 0.5D0, 0.1D0, 2.D+14, 0.025D0, 0.05D0, 0.15D00/
C
C
C
      IF(NFCALL.EQ.0) THEN
      DO 36 I=1,L
      Q1(I)=Q1(I)*0.001D0
      FLUSSG1(I)=FLUSSG1(I)*1.D15
      FLUSSO1(I)=FLUSSO1(I)*1.D15
      FLUSSA1(I)=FLUSSA1(I)*1.D15
      SZC(I) = DCOS(PI*PHI(I)/180.0D0)
   36 LP1(I)=-LP1(I)
      DO 30 J=1,L
      DO 31 I=1,M
      IF(FI(I).GE.PHI(J)) THEN
      J2(J)=I
      GO TO 30
      END IF
   31 CONTINUE
   30 CONTINUE
      END IF
C
C
      NFCALL=NFCALL+1
C
      DO 16 I=1,M
      AP(I) = 1.0D0-ABSORB(I)/(340.0D0*SOLEIL(I))
   16 FL(I) = FLUSSO(I)+FLUSSA(I)+FLUSSQ(I)
C
C     BERECHNUNG DER GERECHNETEN WERTE AN DEN MESSPUNKTEN (L=18)
      DO 32 J=1,L
      I2=J2(J)
      I1=I2-1
      TAX(J)=TA(I1)+(TA(I2)-TA(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      TOX(J)=TO(I1)+(TO(I2)-TO(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      QX(J)=Q(I1)+(Q(I2)-Q(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      HLX(J)=HL(I1)+(HL(I2)-HL(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      HUX(J)=HU(I1)+(HU(I2)-HU(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      BEX(J)=BEW(I1)+(BEW(I2)-BEW(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      APX(J)=AP(I1)+(AP(I2)-AP(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      LPX(J)=LP(I1)+(LP(I2)-LP(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      EVX(J)=EVA(I1)+(EVA(I2)-EVA(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      PX(J)=P(I1)+(P(I2)-P(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      FLX(J)=FL(I1)+(FL(I2)-FL(I1))*(PHI(J)-FI(I1))/(FI(I2)-FI(I1))
      FOX(J)=FLUSSO(I1)+(FLUSSO(I2)-FLUSSO(I1))*(PHI(J)-FI(I1))
     +      /(FI(I2)-FI(I1))
      FAX(J)=FLUSSA(I1)+(FLUSSA(I2)-FLUSSA(I1))*(PHI(J)-FI(I1))
     +      /(FI(I2)-FI(I1))
      FQX(J)=FLUSSQ(I1)+(FLUSSQ(I2)-FLUSSQ(I1))*(PHI(J)-FI(I1))
     +      /(FI(I2)-FI(I1))
   32 CONTINUE
C
C     OBERE SCHRANKE FUER RH
C     DO 15 I=1,M
C       GLIEDER(I,12) = 1.D3*SPRUNG(RH(I)-0.91,0.5D-2)
C  15 CONTINUE
      DO 14 J=1,2
        GLIED(LL+J)=0.0D0
        DO 14 I=1,M
   14 GLIED(LL+J)=GLIED(LL+J)+GLIEDER(I,11+J)
C
C     LEAST SQUARES: Z.B. BEDEUTET DAS GEWICHT 0,02,
C     DA# BEI 2% FEHLER DER BETREFFENDEN GR÷#E EIN BEITRAG ZUR ZIELFKT VON
C     1*SZC(I) ENTSTEHT. DER BEITRAG WIRD IN DEN VEKTOR GLIED AUFGENOMMEN, DEN
C     IMSL-ROUTINE DBCLSJ BENOETIGT
      DO 20 I=1,L
        GLIEDER(I,1) = (TA1(I)-TAX(I))*SZC(I)/G(1)
        GLIEDER(I,2) = (TO1(I)-TOX(I))*SZC(I)/G(1)
        GLIEDER(I,3) = (1.0D0-QX(I)/Q1(I))*SZC(I)/G(2)
        GLIEDER(I,4) = (1.0D0-BEX(I)/BEW1(I))*SZC(I)/G(5)
        GLIEDER(I,5) = (1.0D0-APX(I)/AP1(I))*SZC(I)/G(4)
        GLIEDER(I,6) = (FLUSSO1(I)-FOX(I))*SZC(I)/(G(3))
        GLIEDER(I,9) = (EVA1(I)-EVX(I))*SZC(I)/G(5)
        GLIEDER(I,7) = (HU1(I)-HUX(I))*SZC(I)/G(6)
        GLIEDER(I,8) = (1.0D0-LPX(I)/LP1(I))*SZC(I)/G(4)
        GLIEDER(I,10) = (P1(I)-PX(I))*SZC(I)/G(5)
        GLIEDER(I,11) = (FLUSSG1(I)-FLX(I))*SZC(I)/G(3)
   20 CONTINUE
C
      DO 17 J=1,11
      DO 17 I=1,L
   17 GLIED((J-1)*L+I)=GLIEDER(I,J)
C
      CALL SUMME(M,P,PG)
      CALL SUMME(M,TA,TAG)
      CALL SUMME(M,TS,TSG)
      CALL SUMME(M,Q,QG)
      CALL SUMME(M,ABSA,ABSAG)
      CALL SUMME(M,BEW,BEWG)
      CALL SUMME(M,ABSO,ABSOG)
      CALL SUMME(M,ALBW,ALBWG)
      CALL SUMME(M,HL,HLG)
      CALL SUMME(M,HU,HUG)
      CALL SUMME(M,TAU,TAUH)
      CALL SUMME(M,TAU,TAUH)
C
C INTEGRAL CONSTRAINTS
C
      APG =1.0D0-(ABSAG+ABSOG)/340.0D0
      GHA = (HADLEY(2)-30.0D0)/0.1
      GAP = (APG-0.3D0)/0.01
      GTA = (TAG-14.77D0)/0.05
      GP  = (PG-1.0D0)/0.02
      GTO = (TSG-17.54D0)/0.05
      GTAU = (TAUH-0.2D0)/0.005
      GBEW  = (BEWG-0.6D0)/0.01
C     GHL  = (HL(90)-1.4)/0.01
C     GHU  = (HU(90)-6.0D0)/0.02
      GHU =  1.D2*SPRUNG(HU(1)+0.5-HU(90),0.1D-2)
C     QUOT= (ABSAG/ABSOG-0.44)/0.02
C
C     PARAMETEREINSCHR<SIGMA>NKUNGEN, SOWEIT DIE IM HAUPTPROGRAMM GESETZTEN
C     NICHT AUSREICHEN
C     SONSTIGE CONSTRAINTS: EINIGE WERTE SIND BESONDERS
C     GEFRAGT, DESHALB WERDEN STRAFEN VERHAENGT, WENN DIESE WERTE NICHT ERREICHT
C     WERDEN
C     NIEDERSCHLAG MITTL. BREITEN
      F1(1) = 1.D2*SPRUNG(1.25-PX(5),0.1D-2)
C     TOP
      F1(2) = 1.D3*SPRUNG(10.0D0-Y(18),0.1D-2)
C     NIEDERSCHLAG EQUATOR
      F1(3) = 1.D2*SPRUNG(1.8-PX(10),0.1D-2)
C     CO2
      F1(4) = 1.D3*(SPRUNG(0.059-Y(21),0.1D-2)
     +              +SPRUNG(Y(21)-0.072,0.1D-2))
C     LAPS
      F1(5) = 1.D3*(SPRUNG(Y(33)-0.70D1,0.1D-2)
     +              +SPRUNG(0.60D1-Y(33),0.1D-2))
C     RSURF
      F1(6) = 1.D2*SPRUNG(Y(26)-0.18D0,0.1D-2)
C     ALBEDO LAND
      F1(7) = 1.D2*(SPRUNG(0.15D0-Y(32),0.1D-2)
     +                    +SPRUNG(Y(32)-0.20,0.1D-2))
C     ALBEDO WOLKEN GLOBAL
C     F1(8) = 1.D2*SPRUNG(0.40D0-ALBWG,0.1D-2)
C     GAM
C     F1(9) = 1.D3*(SPRUNG(0.83-Y(20),0.1D-2)
C    +                  +SPRUNG(Y(20)-1.01,0.1D-2))
C     BETA (FEUCHTEABNAHME)
      F1(10) =  1.0D3*SPRUNG(Y(30)-0.37D0,0.1D-2)
C     ALFA1
C     F1(11) = 1.D3*(SPRUNG(0.075-Y(22),0.1D-2)
C    +                  +SPRUNG(Y(22)-0.10,0.1D-2))
C     FLUSSQ MITTL. BREITEN
      F1(11) = 50.0*SPRUNG((1.0D15+FQX(4))/G(3),0.1D-1)
C     HL (ROSS-BREITEN)
      F1(12) = (HL(90)+0.5-HL(120))/0.02
C     BEDINGUNG BEWOELKUNG AEQUATOR
      F1(13) =  1.0D2*SPRUNG(0.60-BEW(90),0.1D-2)
C     ZUSATZ
      ZUSATZ = 0.0D0
      DO 120 I=1,13
 120  ZUSATZ = ZUSATZ+F1(I)**2
      GLIED(LL+3) = GTA
      GLIED(LL+4) = GBEW
      GLIED(LL+5) = GHA
      GLIED(LL+6) = GP
C     GLIED(LL+7) = GTO
      GLIED(LL+8) = GTAU
      GLIED(LL+9) = GAP
      GLIED(LL+10) = QUOT
      GLIED(LL+11) = GHL
      GLIED(LL+12) = GHU
      DO 121 I=1,13
 121    GLIED(LL+I+12) = F1(I)
C
C
C SKALIERUNG
      DO 23 I=1,NOBJ
   23 GLIED(I) = GLIED(I)*0.01D0
      FC = 0.D0
      DO 24 I = 1,M
        GL = 0
        DO 22 J = 1,13
   22   GL = GL+GLIEDER(I,J)**2
   24 FC = FC+GL
      QUAD= GHA**2+GAP**2+GP**2+GTA**2+GTAU**2+GQ**2
     +      +QUOT**2+GHL**2+GHU**2+GBEW**2
      FC = FC+QUAD+ZUSATZ
C
      RETURN
      END
C ===
C
      SUBROUTINE EINGABE(XC,YVEC)
C
C  WIRD NUR ZU ANFANG GERUFEN
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(NX = 33,N = 24,M = 180,M1 = 3,MM = M1*M,NPOL=5,L = 2*9)
      CHARACTER *7 NAME(NX)
      DOUBLE PRECISION KAP1,KAP2,LAM,LAPS
      DIMENSION POL(M,2*NPOL),SUN(5),YDAT(MM),CLAND(4),HOCH(4),
     +XC(NX),Y(NX),YVEC(MM),DELTA(NX),XZWI(M),POLZWI(M,2*NPOL)
C
C
      COMMON/BL1/ALF2,SOLEIL(M),EISFREI(M),EISF(M),SONNE,TROPOS(M)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),FI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL4/LAM(2),EISBED,SWI(M),DICE
      COMMON/BL5/RH(M),TA(M),TS(M),TA1(M),TS1(M),RH1(M)
      COMMON/BL9/VA,VQ,DA,DQ(2),DW(2)
      COMMON/BL10/ LAPS,KAP1,KAP2,ALF1,GAM,UNTEN,THICK,WOLK2,HL(M),HU(M)
     +,WOLK1,ZK(M),ZKK(M),COHLE,QAPS
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CL,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
      COMMON/BL12/PC(2),RMIN,RCRIT,W0,BETA,EXBETA,QRED(M)
      COMMON/NAMELIST/NAME
      COMMON/TRANS/Y,DELTA
      COMMON/TRANSF/TAB,TAE,TSB,TSE,RHB,RHE
C
C
      DATA CLAND/ 0.270232222982D+00,0.305149369507D+00,
     +0.808488720115D-01,0.831306019308D-01/
      DATA HOCH/0.631862171505D+00,0.496757316274D+00,
     +-0.222806946035D+00,-0.310347316230D-01/
      DATA CAA,COO,CPP,ALL/1D7,2D8,1D3,2.5D6/
      DATA SUN/1.,-0.477,-0.045,0.008,0.014/
C
C     STATEMENT FUNCTIONS
C
      EST(TH) = 6.107*10.0D0**(7.5*TH/(237.0D0+TH))
C
C**********************************
C
C
      TAB = -10.D0
      TAE =  10.D0
      TSB = -10.D0
      TSE =  10.D0
      RHB = 0.5D0
      RHE = 1.0D0
C
      ATA = DATAN(1.0D0)
      PI = 4*ATA
      DX = PI/M
      DXX = DX
      DO 19 I=1,M/2
        J=M-I+1
        XZWI(I)=-DX*(M/2-I+1)
        XZWI(J)=-XZWI(I)-DX
        XST(I) = -DX*(M/2-I+0.5D0)
        XST(J) = -XST(I)
        FI(I)  = XST(I)*180.D0/PI
        FI(J)=-FI(I)
        COSM(I)=DCOS(XZWI(I))
        COSM(J)=DCOS(XZWI(J))
        SINM(I) = DSIN(XZWI(I))
        SINM(J) = DSIN(XZWI(J))
        ZC(I) = DCOS(XST(I))
        ZC(J)=ZC(I)
        ZS(I) = DSIN(XST(I))
        ZS(J)=-ZS(I)
   19 CONTINUE
C
C
C+++++++++++++++++++++++++++++++++++++++++++
      CALL EINGAB1(Y,YDAT)
C+++++++++++++++++++++++++++++++++++++++++++
C
      DO 40 I=1,M
        RH1(I)=YDAT(I)
        TA1(I)=YDAT(M+I)
   40   TS1(I)=YDAT(2*M+I)
C
C
C     MAPPING OF YDAT ONTO (-1,+1)
C
      DO 55 I=1,M
        YVEC(M1*I-2)=(2*RH1(I)-(RHE+RHB))/(RHE-RHB)
        YVEC(M1*I-1) = (2*TA1(I)-(2*TA1(I)+TAB+TAE))/(TAE-TAB)
        YVEC(M1*I) = (2*TS1(I)-(2*TS1(I)+TSB+TSE))/(TSE-TSB)
   55 CONTINUE
C
C  NEUE ZUORDNUNG FÜR EINIGE PARAMETER
C
      VA    = Y(1)
      VQ    = Y(2)
      DA    = Y(3)
      DQ(1) = Y(4)
      DQ(2) = Y(5)
      DW(1) = Y(6)
      DW(2) = Y(7)
      PC(1) = Y(8)
      PC(2) = Y(9)
      LAM(1)= Y(10)
      LAM(2)= Y(11)
      RMIN  = Y(12)
      RCRIT = Y(13)
      UNTEN = Y(14)
      THICK = Y(15)
      WOLK1 = Y(16)
      WOLK2 = Y(17)
      TOP   = Y(18)
      UPPER = Y(19)
      GAM   = Y(20)
      COHLE = Y(21)
      ALF1  = Y(22)
      ALF2  = Y(23)
      KAP1  = Y(24)
      EISBED= Y(25)
      RSURF = Y(26)
      DICE  = Y(27)
      SONNE = Y(28)
      HADKOF= Y(29)
      BETA  = Y(30)
      W0    = Y(31)
      ALBL  = Y(32)
      LAPS  = Y(33)
C
C
      KAP2 = KAP1+0.03
      HADK = HADKOF*LAPS
      EXBETA = DEXP(-BETA)
C
      DO 80 I=1,NX
  80  XC(I) = 0.0D0
C
C      WRITE(66,132)
C      WRITE(66,102) (NAME(I),Y(I),I=1,NX)
C
C
C
C***************************************************
C CONSTANTEN
      CQ = 3.0D+03
      RE = 6.37D+06
      FOK = 60**2*24.0D0
      TF = 273.0D0
      TANF = - DICE
      TEND =  DICE
      CA = CAA/FOK
      CO = COO/FOK
      CI = CO/50.0D0
      CL = CA/2.0D0
      CP = CPP/FOK
      AL = ALL/FOK
      COFDA = 2*PI*FOK*CA
      COFDO = 2*PI*FOK*CO
      COFDQ = 2*PI*FOK*AL*CQ
      COF   = 2*PI*RE**2
      COFAT = COFDA/COF
      COFOZ = COFDO/COF
      COFFE = COFDQ/COF
C
C
      DO 83 I=1,M
      DO 84 J=1,2*NPOL
      CALL LEGEND(SINM(I),J,POLZWI(I,J))
   84 CALL LEGEND(ZS(I),J,POL(I,J))
   83 CONTINUE
C
      DO 12 I=1,M/2
        J=M-I+1
        TOS = SUN(1)
        DO 14 IJ=1,4
   14   TOS = TOS+POL(I,2*IJ)*SUN(IJ+1)
        SOLEIL(I) = TOS
        SOLEIL(J)=SOLEIL(I)
   12 CONTINUE
C
      DO 21 I=1,M
      TOS=CLAND(1)
      DO 20 IJ=1,3
   20 TOS = TOS+POL(I,IJ)*CLAND(IJ+1)
      GSUED=1.-SUMP(75.0D0+FI(I),1.0D0,-10.0D0,10.0D0)
      GNORD=SUMP(75.0D0-FI(I),1.0D0,-10.0D0,10.0D0)
      FLAND(I)=GNORD*TOS+GSUED+1.0D-20
C
      TOS=CLAND(1)
      DO 24 IJ=1,3
   24 TOS = TOS+POLZWI(I,IJ)*CLAND(IJ+1)
      GSUED=1.0D0-SUMP(75.0D0+XZWI(I)*180.0D0/PI,1.0D0,-10.0D0,10.0D0)
      GNORD=SUMP(75.0D0-XZWI(I)*180.0D0/PI,1.0D0,-10.0D0,10.0D0)
      XLAND(I)=GNORD*TOS+GSUED+1.0D-20
C
      TOS=HOCH(1)
      DO 22 IJ=1,3
   22 TOS = TOS+POL(I,IJ)*HOCH(IJ+1)
      GSUED=1.-SUMP(75.0D0+FI(I),1.0D0,-10.0D0,10.0D0)
      CORR= 0.2D0+0.3D0/(1.0D0+10.0D0*(FI(I)/35.0D0-1.0D0)**2)
      HEIGHT(I)=TOS*CORR+2.272D0*GSUED
      QRED(I) = DEXP(-BETA*HEIGHT(I))
C
      TOS=HOCH(1)
      DO 25 IJ=1,3
   25 TOS = TOS+POLZWI(I,IJ)*HOCH(IJ+1)
      GSUED=1.-SUMP(75.0D0+XZWI(I)*180.0D0/PI,1.0D0,-10.0D0,10.0D0)
      CORR= 0.2D0+0.3D0/(1.0D0+10.0D0*
     +     (XZWI(I)*180.0D0/PI/35.0D0-1.0D0)**2)
      XHEIGHT(I)=TOS*CORR+2.272D0*GSUED
C
   21 CONTINUE
C
      DO 10 I=1,M/2
        J=M-I+1
        ZK(I) = ZS(I)**2
        ZK(J) = ZK(I)
        TROPOS(I) = TOP-3.0D0*(TOP-10.0)*ZK(I)
        TROPOS(J) = TROPOS(I)
        EISFREI(I) = RSURF*(1.0D0-0.5D0*SOLEIL(I))
        EISFREI(J) = EISFREI(I)
        GRADC(I) = -HADK*(ZC(I)/ZS(I))
        GRADC(J) = -GRADC(I)
C       SWI(I) = SUMP(DABS(FI(I))-70.0D0,0.5D0,-3.0D0,3.0D0)
C       SWI(J) = SWI(I)
C       EISF(I) = ALBL*(1.0D0-SWI(I))+ALBE*SWI(I)
        EISF(I) = ALBL
        EISF(J) = EISF(I)
        ZKK(I) = 0.5*SOLEIL(I)/(1.0D0-0.5*SOLEIL(I))
        ZKK(J) = ZKK(I)
   10 CONTINUE
C
C
  132 FORMAT(' BEGINN')
  102 FORMAT(3(1X,A7,E12.5,1X))
  110 FORMAT(' TS='/3(E11.4))
  111 FORMAT(' Y='/5(E10.3))
  108 FORMAT(' TA='/3(E11.4))
  109 FORMAT(' RH='/3(E11.4))
  121 FORMAT(' FC='/5(E11.4))
      RETURN
      END
C ===
C
      SUBROUTINE WOLF(XC,YVEC,FVEC,FALL)
C ZWISCHENGESCHALTETES PROGRAMM, NUR FUER OPTIMIERUNG
C CALLS FCN
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL
      PARAMETER(M = 180,M1 = 3,MM = M1*M)
      PARAMETER(NX = 33,NPOL=5)
C
      DIMENSION YVEC(MM),FVEC(MM),XC(NX),Y(NX)
      DOUBLE PRECISION KAP1,KAP2,LAM,LAPS
C
      COMMON/BL1/ALF2,SOLEIL(M),EISFREI(M),EISF(M),SONNE,TROPOS(M)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),PHI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL4/LAM(2),EISBED,SWI(M),DICE
      COMMON/BL5/RH(M),TA0(M),TS0(M),TAE(M),TSE(M),RHE(M)
      COMMON/BL9/VA,VQ,DA,DQ(2),DW(2)
      COMMON/BL10/ LAPS,KAP1,KAP2,ALF1,GAM,UNTEN,THICK,WOLK2,HL(M),HU(M)
     +,WOLK1,ZK(M),ZKK(M),COHLE,PL
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CL,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
      COMMON/BL12/PC(2),RMIN,RCRIT,W0,BETA,EXBETA,QRED(M)
      COMMON/DRUCK/TO(M),TS(M),TA(M),EISL(2),BEW(M),ABSORB(M),
     +EMIT(M),HADLEY(2),H(M),ALAT(M),OLAT(M),SNOW(2),
     +AFLUX(M),QFLUX(M),OFLUX(M),PCRIT(M),
     +RA(M),RO(M),EVA(M),PTOTAL(M),Q(M),GRAT(M),GRADQ(M)
      COMMON/TRANS/YALT(NX),DELTA(NX)
      COMMON/COEFFI/Y
C
C     Y() PARAMETERS IN PHYSICAL SPACE
C     VARIATIONSBEREICH VON Y:  PLUS/MINUS DELTA*PSTART
C     VARIATIONSBEREICH VON XC: 2
C     VERKLEINERUNG VON DELTA VERRINGERT DEN GRADIENTEN  BZGL. XC
C     DELTA KANN INDIVIDUELL ANGEPASST WERDEN, ENTSPRECHEND DEM
C     GEWUENSCHTEN BEREICH VON Y()
C
      DO 333 I=1,NX
 333  DELTA(I)=0.3
      DELTA(9)=0.9
      DO 69 I=1,NX
   69 Y(I)=YALT(I)*(XC(I)*DELTA(I)+1.0D0)
C
      VA    = Y(1)
      VQ    = Y(2)
      DA    = Y(3)
      DQ(1) = Y(4)
      DQ(2) = Y(5)
      DW(1) = Y(6)
      DW(2) = Y(7)
      PC(1) = Y(8)
      PC(2) = Y(9)
      LAM(1)= Y(10)
      LAM(2)= Y(11)
      RMIN  = Y(12)
      RCRIT = Y(13)
      UNTEN = Y(14)
      THICK = Y(15)
      WOLK1 = Y(16)
      WOLK2 = Y(17)
      TOP  = Y(18)
      UPPER = Y(19)
      GAM   = Y(20)
      COHLE = Y(21)
      ALF1  = Y(22)
      ALF2  = Y(23)
      KAP1  = Y(24)
      EISBED= Y(25)
      RSURF = Y(26)
      DICE  = Y(27)
      SONNE = Y(28)
      HADKOF= Y(29)
      BETA  = Y(30)
      W0    = Y(31)
      ALBL  = Y(32)
      LAPS  = Y(33)
C
      TANF = - DICE
      TEND =  DICE
      KAP2 = KAP1+0.03
      HADK = HADKOF*LAPS
      PL = 34.15/LAPS
      EXBETA = DEXP(-BETA)
C
C
      DO 10 I=1,M/2
        J=M-I+1
        TROPOS(I) = TOP-3.0D0*(TOP-10.0)*ZK(I)
        EISFREI(I) = RSURF*(1.0D0-0.5D0*SOLEIL(I))
        GRADC(I) = -HADK*(ZC(I)/ZS(I))
        EISF(I) = ALBL
C       EISF(I) = ALBL*(1.0D0-SWI(I))+ALBE*SWI(I)
        TROPOS(J) = TROPOS(I)
        EISFREI(J)=EISFREI(I)
        GRADC(J) = -GRADC(I)
        EISF(J) = EISF(I)
   10 CONTINUE
      DO 11 I=1,M
   11 QRED(I) = DEXP(-BETA*HEIGHT(I))
C
C+++++++++++++++++++++++++++++++++++++++
      CALL FCN(YVEC,FVEC,FALL)
C+++++++++++++++++++++++++++++++++++++++++
C
      RETURN
      END
C ===
C
      SUBROUTINE FCN(Y,F,FALL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL
      PARAMETER (M = 180,M1 = 3,MM = M1*M)
C
      DOUBLE PRECISION LAMDA(M),LA,LO,LAM,IRA,IRL,LAPS,NULL(M)
      DOUBLE PRECISION KAPPA(M),KAPPAL(M),KAPPAW(M)
C
      DIMENSION DIVFA(M),DIVFO(M),TAA(M),TOO(M),TLL(M),Q(M)
     +,TSS(M),DIVFQ(M),HAD(2),Y(MM),F(MM),SWITCH(M),QSTO(M),QL(M)
     +,P(M),REF(M),REFL(M),BLAM1(M),BLAM2(M),EWASSER(M),PS(M)
     +,QSTI(M),QSTL(M),QSTLI(M),GRA(M),ELAND(M),BEWL(M)
     +,ABSAA(M),ABSOO(M),ABSOL(M),LA(M),LO(M)
     +,GRADTA(M),SCHALT(M),IRA(M),IRL(M),ABSAL(M),QUOTW(M)
     +,GRADTO(M),GRADQ(M),TAL(M),ALBWW(M),ALBWL(M),QUOTL(M)
     +,HLW(M),HLL(M),HUW(M),HUL(M),CONTRL(6*M),CONTRW(6*M)
C
C
      COMMON/BL1/ALF2,SOLEIL(M),EISFREI(M),EISF(M),SUN,TROPOS(M)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),FI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL4/LAM(2),EISBED,SWI(M),DICE
      COMMON/BL5/RH(M),TA(M),TS(M),TA1(M),TS1(M),RH1(M)
      COMMON/BL10/ LAPS,ZAP1,ZAP2,ALF1,GAM,UNTEN,THICK,WOLK2,HL(M),HU(M)
     +,WOLK1,ZK(M),ZKK(M),COHLE,PL
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CL,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
      COMMON/BL12/PC(2),RMIN,RCRIT,W0,BETA,EXBETA,QRED(M)
C
      COMMON/DRUCK/TO(M),TSTR(M),TASTR(M),EISL(2),BEW(M),ABSORB(M),
     +EMIT(M),HADLEY(2),H(M),ALAT(M),OLAT(M),SNOW(2),
     +AFLUX(M),QFLUX(M),OFLUX(M),PCRIT(M),
     +RA(M),RO(M),EVA(M),PTOTAL(M),QSTR(M),GRAT(M),GRATQ(M)
      COMMON/AUSG1/DUMMY(6*M),FLUSSA(M),FLUSSO(M),FLUSSQ(M)
      COMMON/AUSG2/AMDA(M),STO(M),STA(M),ABSO(M),ABSA(M),
     +             ALBB(M),ALBH2O(M),ALBW(M)
      COMMON/AUSG4/QUOT(M),CONTR(6*M),KAPPA,W(M)
      COMMON/TRANSF/TAB,TAE,TSB,TSE,RHB,RHE
C
C
      DATA SOL/340.0D0/
      DATA NULL/M*0.0D0/
      DATA EPST,EPSB,BLAND/0.1D0,0.02D0,2.0/
      DATA UMRECH/2.739726027D0/
C
C
C STATEMENT FUNCTIONS
C
      FLEG(X) = 0.5D0*(3.0D0*X*X-1)
C     SCH(TOS) = 0.5D0*DATAN(70.0D0*(TOS-273.0D0))/ATA
C     EST, ESTI IN DER BEDEUTUNG VON DAMPFDRUCK
      EST(TH) = 6.107*10.0D0**(7.5*TH/(237.0D0+TH))
      ESTI(TH) = 6.107*10.0D0**(9.5*TH/(265.5D0+TH))
C
C
      EISLAND=EISBED+0.1
      DO 20 I=1,M
        RH(I)=(Y(M1*I-2)*(RHE-RHB)+(RHE+RHB))*0.5D0
        TAA(I) = (Y(M1*I-1)*(TAE-TAB)+2.0D0*TA1(I)+TAB+TAE)*0.5D0+273.D0
        TSS(I) = (Y(M1*I)*(TSE-TSB)+2.0D0*TS1(I)+TSB+TSE)*0.5D0+273.0D0
        TA(I) = TAA(I)-273.0D0
        TS(I) = TSS(I)-273.0D0
C
        IF(DABS(TA(I)).GT.150.0D0) THEN
C          WRITE(*,*) 'ABS(TA) GT. 150'
C          WRITE(*,*) I,TA(I)
C          STOP 'STOP 8'
         FALL=8.
         RETURN
        END IF
C
        QSTA = 6.22D-4*EST(TA(I))
        Q(I) = RH(I)*QSTA
C
        IF(RH(I).GE.1.0D0) THEN
C          WRITE(*,*) ' RH GROESSER ALS EINS'
C          WRITE(*,*) I,RH(I)
C          STOP 'STOP 9'
         FALL=9.
         RETURN
        END IF
C
        IF(RH(I).LE.0.0D0) THEN
C          WRITE(*,*) ' RH KLEINER ALS NULL'
C          WRITE(*,*) I,RH(I)
C          STOP 'STOP 10'
         FALL=10.
         RETURN
        END IF
C
        QSTO(I) = 6.22D-4*EST(TS(I))
        QSTI(I) = 6.22D-4*ESTI(TS(I))
        TOO(I) = TF+SPRUNG(TSS(I)-TF,TEND)
        TO(I) = TOO(I)-273.0D0
        SCHALT(I) = SUMP(TSS(I)-TF,EPST,TANF,TEND)
        REF(I)=EISFREI(I)*SCHALT(I)+EISBED*(1.0D0-SCHALT(I))
        ALBH2O(I)=REF(I)
C
C       LAND......
        TAL(I) = TAA(I)-LAPS*HEIGHT(I)
        TLL(I) = TAL(I)
C SWITCH(LAND) ENTSPRICHT SCHALT(WASSER), DIE BREITE DES
C NICHTLINEAREN STUECKS IST GEGEN DAS WASSER UM DEN FAKTOR
C BLAND VERGR÷#ERT; HIER: BLAND=2
        QSTL(I) = QSTA*QRED(I)
        QSTLI(I) = 6.22D-4*ESTI(TA(I))*QRED(I)
        SWITCH(I)= SUMP(TLL(I)-TF,EPST,-BLAND*DICE,BLAND*DICE)
        QL(I) = Q(I)*QRED(I)
        TASTR(I) = TAL(I)*FLAND(I)+TAA(I)*(1.0D0-FLAND(I))-273.0D0
        TSTR(I) = FLAND(I)*TLL(I)+(1.0D0-FLAND(I))*TSS(I)-273.0D0
        QSTR(I) = FLAND(I)*QL(I)+(1.0D0-FLAND(I))*Q(I)
        REFL(I) = EISF(I)*SWITCH(I)+EISLAND*(1.0D0-SWITCH(I))
        ALBB(I) = REFL(I)
        BEW(I) = SUMP(RH(I),EPSB,RMIN,1.0D0-EPSB)
C       BEW(I) = SUMP(RH(I),EPSB,RMIN*(1.0+0.1*HEIGHT(I)),1.0D0-EPSB)
        BEWL(I) = BEW(I)*0.75
   20 CONTINUE
C
        DO 32 I=2,M-1
        GRADTA(I) = (TA(I+1)-TA(I-1))/(2*DX)
        GRADTO(I) = (TS(I+1)-TS(I-1))/(DX*2)
        GRADQ(I) = (Q(I+1)-Q(I-1))/(2*DX)
   32 CONTINUE
        GRADTA(1) = (TA(2)-TA(1))/(2*DX)
        GRADTA(M) = (TA(M)-TA(M-1))/(2*DX)
C
        GRADQ(1)=(Q(2)-Q(1))/(2*DX)
        GRADTO(1)=(TS(2)-TS(1))/(2*DX)
        GRADTO(M)=(TS(M)-TS(M-1))/(2*DX)
        GRADQ(M)=(Q(M)-Q(M-1))/(2*DX)
      DO 33 I=1,M
        GRA(I) = DABS(GRADTA(I))
   33 CONTINUE
C
C
C EISLINIE
      CALL EISLI(TSS,EISL)
C
C SCHNEELINIE
      CALL EISLI(TAA,SNOW)
C
C
C HADLEY LINIE
      CALL HADL(DX,XST,GRADTA,GRADC,HAD)
      DO 29 K=1,2
   29 HADLEY(K) = HAD(K)*180.0D0/PI
C
C  WIND (LAMDA) UND VERTICALGESCHW. (W), WELCHE DIE WOLKENDICKE BESTIMMT
      DO 62 I=1,M
      BLAM1(I) = SPRUNG(1.0D0-GRADTA(I)/GRADC(I),0.3D0)
      BLAM2(I) = SPRUNG(1.-DABS(GRADC(I)/GRADTA(I)),0.4D0)
      BLAM3 = SPRUNG(1.0D0-3.0*GRADTA(I)/GRADC(I),0.3D0)
C     LAMDA(I) = LAM(1)+LAM(2)*GRA(I)*BLAM2(I)
C     W(I) = 1.0 + PC(2)*GRA(I)*BLAM2(I)
      LAMDA(I) = LAM(1) + GRA(I)*(LAM(2)*ZC(I)*BLAM2(I)
     +           +LAM(1)*0.07*BLAM1(I))
      W(I) = BLAM3 + ZC(I)*PC(2)*GRA(I)*BLAM2(I)
   62 CONTINUE
C
C
C
C
C
C*******************************************
      CALL DISKRET(TAA,TSS,TSS,Q,DIVFA,DIVFO,DIVFQ,
     +GRADTA,GRADTO,GRADQ,GRA,BLAM1,SCHALT)
C*********************************************
C     1. RUF VON STRAHL F<^N>R DIE MEERESOBERFL<SIGMA>CHE (H÷HE=NULL)
C     2. RUF VON STRAHL F<^N>R DIE LANDOBERFL<SIGMA>CHE (H÷HE=HEIGHT)
C
C****************************************************************
      CALL STRAHL(TAA,TSS,ABSAA,ABSOO,LA,LO,BEW,REF,NULL,RH,
     +            Q,1,ALBWW,CONTRW,HLW,HUW,KAPPAW,QUOTW,W,FALL)
C
      CALL STRAHL(TAA,TLL,ABSAL,ABSOL,IRA,IRL,BEWL,REFL,HEIGHT,RH,
     +            Q,2,ALBWL,CONTRL,HLL,HUL,KAPPAL,QUOTL,W,FALL)
C*****************************************************************
C
      DO 17 I=1,M
        HL(I)=HLL(I)*FLAND(I)+HLW(I)*(1.0-FLAND(I))
        HU(I)=HUL(I)*FLAND(I)+HUW(I)*(1.0-FLAND(I))
        CONTR(I)=CONTRL(I)*FLAND(I)+CONTRW(I)*(1.0-FLAND(I))
        CONTR(I+M)=CONTRL(I+M)*FLAND(I)+CONTRW(I+M)*(1.0-FLAND(I))
        CONTR(I+2*M)=CONTRL(I+2*M)*FLAND(I)+CONTRW(I+2*M)*(1.0-FLAND(I))
        CONTR(I+3*M)=CONTRL(I+3*M)*FLAND(I)+CONTRW(I+3*M)*(1.0-FLAND(I))
        CONTR(I+4*M)=CONTRL(I+4*M)*FLAND(I)+CONTRW(I+4*M)*(1.0-FLAND(I))
        CONTR(I+5*M)=CONTRL(I+5*M)*FLAND(I)+CONTRW(I+5*M)*(1.0-FLAND(I))
        ALBW(I)=ALBWL(I)*FLAND(I)+ALBWW(I)*(1.0-FLAND(I))
        QUOT(I)=QUOTL(I)*FLAND(I)+QUOTW(I)*(1.0-FLAND(I))
        KAPPA(I)=KAPPAL(I)*FLAND(I)+KAPPAW(I)*(1.0-FLAND(I))
   17 CONTINUE
C
C*********************************************
      CALL MOIST(QSTO,QSTL,QSTI,QSTLI,LAMDA,EWASSER,ELAND,P,BEW,
     +           BEWL,RH,PS,SCHALT,Q)
C*****************************************************************
C
C
      DO 16 I=1,M
        BEW(I) = FLAND(I)*BEWL(I)+(1.0D0-FLAND(I))* BEW(I)
        AMDA(I) = LAMDA(I)
        GRAT(I) = GRADTA(I)
        GRATQ(I) = GRADQ(I)
        PCRIT(I) = PS(I)
C PTOTAL: TOTAL PRECIPITATION
        PTOTAL(I) = P(I)+PCRIT(I)
        RSONNE = SOL*SOLEIL(I)*SUN
C ABSORB: TOTAL SHORTWAVE ABSORPTION
        ABSORB(I) = (FLAND(I)*(ABSOL(I)+ABSAL(I))+(1.0D0-FLAND(I))*
     +  (ABSAA(I)+ABSOO(I)))*RSONNE
C EMIT: TOTAL LONGWAVE EMISSION TO SPACE
        EMIT(I) = FLAND(I)*(IRL(I)+IRA(I))+(1.0D0-FLAND(I))
     +  *(LA(I)+LO(I))
C ABSA, ABSO: SHORTWAVE ABSORPTION OF ATMOSPHERE(A) AND OCEAN(O)
        ABSA(I) = (FLAND(I)*ABSAL(I)+(1.0D0-FLAND(I))*
     +  ABSAA(I))*RSONNE
        ABSO(I) = (FLAND(I)*ABSOL(I)+(1.0D0-FLAND(I))*
     +  ABSOO(I))*RSONNE
C STA, STO: LONGWAVE EMISSION OF ATMOSPHERE(A) AND OCEAN(O)
        STA(I) = FLAND(I)*IRA(I)+(1.0D0-FLAND(I))
     +  *LA(I)
        STO(I) = FLAND(I)*IRL(I)+(1.0D0-FLAND(I))
     +  *LO(I)
C RLA: RADIATION BALANCE OF ATMOSPHERE OVER LAND
        RLA = ABSAL(I)*RSONNE+IRA(I)
C RL: RADIATION BALANCE OF LAND SURFACE
        RL = ABSOL(I)*RSONNE+IRL(I)
C RWA: RADIATION BALANCE OF ATMOSPHERE OVER WATER
        RWA = ABSAA(I)*RSONNE+LA(I)
C RW: RADIATION BALANCE OF WATER SURFACE
        RW = ABSOO(I)*RSONNE+LO(I)
C RA: TOTAL RADIATION BALANCE OF ATMOSPHERE
        RA(I) = FLAND(I)*RLA+(1.0D0-FLAND(I))*RWA
C RO: TOTAL RADIATION BALANCE OF OCEAN
        RO(I) = FLAND(I)*RL+(1.0D0-FLAND(I))*RW
C H:  SENSIBLE VERTICAL HEAT FLUX
        H(I) = (1.0D0-FLAND(I))*LAMDA(I)*(TSS(I)-TAA(I))
        ALAT(I) = AL*PTOTAL(I)*UMRECH
C EVA: EVAPORATION
        EVA(I) = FLAND(I)*ELAND(I)+(1.0D0-FLAND(I))*EWASSER(I)
        OLAT(I) = AL*EVA(I)*UMRECH
        OLAND = AL*ELAND(I)*UMRECH
        OWASSER = AL*EWASSER(I)*UMRECH
        AFLUX(I) = DIVFA(I)*COFAT
        OFLUX(I) = DIVFO(I)*COFOZ
        QFLUX(I) = DIVFQ(I)*COFFE
        FX = AFLUX(I)+H(I)+ALAT(I)+RA(I)+
     +  FLAND(I)*RL-FLAND(I)*OLAND
        FY = OFLUX(I)/(1.0D0-FLAND(I))-H(I)/(1.0D0-FLAND(I))+RW-OWASSER
        FZ = OLAT(I)+QFLUX(I)-ALAT(I)
        F(M1*I)   = FY*0.01D0
        F(M1*I-1) = FX*0.01D0
        F(M1*I-2) = FZ*0.01D0
   16 CONTINUE
C
      RETURN
      END
C ===
C
      SUBROUTINE DISKRET(TA,TS,TO,Q,DIVFA,DIVFO,DIVFQ,
     +GRADTA,GRADTO,GRADQ,GRA,FX,SCHALT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(M = 180,M1 = 3,MM = M1*M)
C
      DIMENSION TA(M),TS(M),TO(M),Q(M),DIVFA(M),DIVFO(M),DIVFQ(M),
     +DA(M),DQ(M),DKO(M),GA(M),GO(M),GQ(M),ADVA(M),ADVQ(M),
     +FLUSSA(M),FLUSSO(M),FLUSSQ(M),GRADTA(M),GRADTO(M),GRADQ(M),
     +DFLUSSA(M),DFLUSSO(M),DFLUSSQ(M),AFLUSSA(M),AFLUSSO(M),
     +AFLUSSQ(M),VA(M),VQ(M),GRA(M),VO(M),DW(M),SCHALT(M)
      DIMENSION DKA(M),DKQ(M),FX(M),ONORD(M),OSUED(M)
C
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),FI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL9/VAA,VQQ,DAA,DQQ(2),DWW(2)
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CLAND,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
C     COMMON/BL12/PC(2),RMIN,RCRIT,W0,BETA,QRED(M)
      COMMON/AUSG1/VA,VQ,VO,DKA,DKO,DKQ,FLUSSA,FLUSSO,FLUSSQ
C
      OTNEG(X) = 0.5D0*(1.0D0+DSIGN(1.D0,X))
      PNOT(X)=0.5D0*(1.0D0-DSIGN(1.D0,X))
C
C
      DO 10 I=2,M
        GA(I) = (TA(I)-TA(I-1))/DX
        GQ(I) = (Q(I)-Q(I-1))/DX
        GO(I) = (TO(I)-TO(I-1))/DX
   10 CONTINUE
      GA(1)=0.0D0
C
C
      DO 57 I=1,M
        VQ(I) = VQQ*FX(I)*GRADTA(I)
        DKQ(I) =(DQQ(2)*GRA(I)+DQQ(1))
        DKA(I) = DAA*GRA(I)+DQQ(1)+VAA*FX(I)*TA(I)*RE
C  57 DKO(I) = DWW(2)*SCHALT(I)*(1.0D0-2.0D0*ZS(I)**2+ZS(I)**4)+DWW(1)
   57 DKO(I) = DWW(2)*(1.0D0-2.0D0*ZS(I)**2+ZS(I)**4)+DWW(1)
C
C DKO: DIFFUSION COEFFICIENT OCEAN
C DKA: DIFFUSION COEFFICIENT ATMOSPHERE
C DKQ: DIFFUSION COEFFICIENT HUMIDITY
C VQ: ADVECTION HUMIDITY
C DQ,DW,DA: DIFFUSION COEFFICIENTS FOR DISCRETIZATION FORMULAE
C
      DO 58 I=2,M
        RFAK = DABS(GA(I))
        FXZWI = SPRUNG(1.0D0+GA(I)*SINM(I)/(HADK*COSM(I)),0.3D0)
        DQ(I) = DQQ(2)*RFAK+DQQ(1)
        DA0 = DAA*RFAK+DQQ(1)
        SCHA=SUMP((TS(I)+TS(I-1))*0.5D0-TF,0.1D0,TANF,TEND)
C       DW(I) = (DWW(2)*SCHA*(1.0D0-2.0D0*SINM(I)**2+SINM(I)**4)+DWW(1))
C    +          *(1.0D0-XLAND(I))
        DW(I) = (DWW(2)*(1.0D0-2.0D0*SINM(I)**2+SINM(I)**4)+DWW(1))
     +          *(1.0D0-XLAND(I))
   58 DA(I)=DA0+VAA*RE*FXZWI*(TA(I)+TA(I-1))*0.5D0
C
C
      DO 56 I=1,M
        AFLUSSA(I) = 0.0D0
        AFLUSSO(I) = 0.0D0
        AFLUSSQ(I) = ZC(I)*VQ(I)*Q(I)*COFDQ*RE
        DFLUSSA(I) = -ZC(I)*DKA(I)*GRADTA(I)*COFDA
        DFLUSSO(I) = -ZC(I)*DKO(I)*GRADTO(I)*COFDO
        DFLUSSQ(I) = -ZC(I)*DKQ(I)*GRADQ(I)*COFDQ
C FLUSSA, FLUSSO, FLUSSQ: TOTAL FLUXES FOR ATMOS, OCEAN, HUMIDITY
        FLUSSA(I) = (AFLUSSA(I)+DFLUSSA(I))
        FLUSSO(I) = (AFLUSSO(I)+DFLUSSO(I))*(1.0D0-FLAND(I))
        FLUSSQ(I) = (AFLUSSQ(I)+DFLUSSQ(I))
   56 CONTINUE
C
C
C ADVECTION
C ADVECTIVE FLUX OF ATMOSPHERE CAN BE SUBSUMIZED UNDER DIFFUSION, BECAUSE
C ADVECTIVE AND DIFFUSIVE FLUX ARE OF EQUAL SIGN
C ADVECTIVE FLUX OF HUMIDITY IS OPPOSITE TO DIFFUSIVE FLUX OF HUMIDITY, SO
C IT MUST BE TREATED SEPARATELY
      DO 33 I=1,M
      SCHA=OTNEG(GA(I))-PNOT(GA(I))
      ONORD(I)=0.5D0*(1.0D0+SCHA)
      OSUED(I)=0.5D0*(1.0D0-SCHA)
      ONORD(I)=0.5D0*(1.0D0+DSIGN(1.0D0,GA(I)))
      OSUED(I)=0.5D0*(1.0D0-DSIGN(1.0D0,GA(I)))
   33 CONTINUE
C
C
C ADVQ : ADVECTION OF HUMIDITY
C
C
      F2 = SPRUNG(1.D0-GA(2)/GRADC(1),0.3D0)
      FY2 = SPRUNG(1.D0-GA(2)/GRADC(2),0.3D0)
      FRECHTS = GA(2)*Q(1)*ZC(1)*F2*ONORD(1)+GA(2)*Q(2)*ZC(2)*FY2
     +          *OSUED(1)
      FLINKS = 0.D0
      ADVQ(1) = VQQ*(FRECHTS-FLINKS)
C
      F1 =  SPRUNG(1.D0-GA(M)/GRADC(M-1),0.3D0)
      FY1 =  SPRUNG(1.D0-GA(M)/GRADC(M),0.3D0)
C
      DO 62 I=2,M-1
      F2=SPRUNG(1.D0-GA(I+1)/GRADC(I),0.3D0)
      FY2=SPRUNG(1.D0-GA(I+1)/GRADC(I+1),0.3D0)
      FLINKS = FRECHTS
      FRECHTS = GA(I+1)*Q(I)*ZC(I)*F2*ONORD(I)+GA(I+1)*Q(I+1)*ZC(I+1)
     +          *FY2*OSUED(I)
      ADVQ(I) = VQQ*(FRECHTS-FLINKS)
   62 CONTINUE
C
C
      FLINKS = GA(M)*Q(M-1)*ZC(M-1)*F1*ONORD(M)+GA(M)*Q(M)*ZC(M)*FY1
     +         *OSUED(M)
      FRECHTS = 0.D0
      ADVQ(M) = VQQ*(FRECHTS-FLINKS)
C
      DO 44 I=1,M
      ADVA(I)=0.0D0
      ADVQ(I)=ADVQ(I)*RE
   44 CONTINUE
C
C DIFFUSION
      DO 12 I=2,M-1
        DIFUSA = DA(I+1)*COSM(I+1)*GA(I+1)-DA(I)*COSM(I)
     +           *GA(I)
        DIVFA(I) = (DIFUSA-ADVA(I))/(DX*ZC(I))
        DIFUSQ = DQ(I+1)*COSM(I+1)*GQ(I+1)- DQ(I)*COSM(I)*GQ(I)
        DIVFQ(I) = (DIFUSQ-ADVQ(I))/(DX*ZC(I))
        DIFUSO = DW(I+1)*COSM(I+1)*GO(I+1)-DW(I)*COSM(I)*GO(I)
        DIVFO(I) = DIFUSO/(DX*ZC(I))
   12 CONTINUE
C
      DIFUSA = DA(2)*COSM(2)*GA(2)
      DIVFA(1) = (DIFUSA-ADVA(1))/(DX*ZC(1))
      DIFUSA = -DA(M)*COSM(M)*GA(M)
      DIVFA(M) = (DIFUSA-ADVA(M))/(DX*ZC(M))
      DIFUSQ = DQ(2)*COSM(2)*GQ(2)
      DIVFQ(1) = (DIFUSQ-ADVQ(1))/(DX*ZC(1))
      DIFUSQ = -DQ(M)*COSM(M)*GQ(M)
      DIVFQ(M) = (DIFUSQ-ADVQ(M))/(DX*ZC(M))
      DIFUSO = DW(2)*COSM(2)*GO(2)
      DIVFO(1) = DIFUSO/(DX*ZC(1))
      DIFUSO = DW(M)*COSM(M)*GO(M)
      DIVFO(M) = -DIFUSO/(DX*ZC(M))
C
      RETURN
      END
C ===
C
      SUBROUTINE STRAHL(TA,TO,ABSA,ABSO,LA,LO,BEW,ASS,BERG,RH,
     +                  Q,L,ALBW,CONTR,HLS,HUS,KAPPA,CQUOT,W,FALL)
C  TA IST IMMER AUF HEIGHT=0 BEZOGENE GROESSE
C  TO IST TLAND, WENN L=2
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL
      PARAMETER (M = 180,M1 = 3,MM = M1*M)
C
      DOUBLE PRECISION KAPPA(M),LA,LO,KAP1,KAP2,LAPS,LG,KAPPA1,KAPPA2
C
      DIMENSION TA(M),TO(M),ABSA(M),ABSO(M),RH(M),Q(M),W(M)
     +,BEW(M),LA(M),LO(M),CQUOT(M),ASS(M),BERG(M),ALBW(M),DICKE(M)
     +,HL(M),HU(M),Q1000(M),WEGUB(M),WEGH(M),WEGL0(M),WEGU(M)
     +,FA(M),FF(M),HLS(M),HUS(M),CONTR(6*M)
      COMMON/BL1/ALF2,SONNE(M),EISFREI(M),EISF(M),SUN,TROPOS(M)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),FI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL10/LAPS,KAP1,KAP2,ALF1,GAM,UNTEN,THICK,WOLK2,DU1(M)
     +,DU2(M),WOLK1,ZK(M),ZKK(M),COHLE, PL
      COMMON/BL12/PC(2),RMIN,RR,W0,BETA,EXBETA,QRED(M)
      COMMON/STMO/WEGCLW(M),WEGCLL(M)
C
      DATA CO2,SIGMA/ 350.0D0, 0.57D-7/
      DATA A1,A2/237.0D0,17.2694D0/
C
C     STATEMENT FUNCTIONS
      EST(TH) = 6.107D0*10.0D0**(7.5D0*TH/(237.0D0+TH))
      F(T) = SIGMA*(T*T)*(T*T)
      QHOEH(X) = DEXP(-BETA*X)/BETA
C
C
      GO TO (30,31),L
 30   DO 10 I=1,M
        Q1000(I) = Q(I)*1000.0D0
        FA(I) = F(TA(I))
        FF(I) = F(TO(I))
C       WEGH: PATH-LENGTH FROM BERG TO TROPOS
        WEGH(I) = Q1000(I)/BETA
        ZR = SUMP(RH(I),1.0D-2,1.0D-2,0.99D0)
        ZRH = 1.0D-4+ZR*0.9999
        HL(I) = -UNTEN*A1/(A2*LAPS)*DLOG(ZRH)
        IF (HL(I) .GT. TROPOS(I)-0.05) THEN
          HL(I) = TROPOS(I)-0.05
          HU(I) = TROPOS(I)
          GO TO 11
        END IF
C
        DICKE(I) = 0.758*THICK*(1.0+W(I))
        HU(I) = DICKE(I)+HL(I)
        IF(HU(I).GT.TROPOS(I)) HU(I) = TROPOS(I)
C  ES SOLLTE GELTEN: BERG<HL(I)<HU(I)<TROPOS  !!
  11    CONTINUE
        R1 = QHOEH(HL(I))
        R2 = QHOEH(HU(I))
C  WEGUB: PATH-LENGTH FROM HL TO HU
        WEGUB(I) = Q1000(I)*(R1-R2)
        WEGCLW(I)=WEGUB(I)
C  WEGL0: PATH-LENGTH FROM BERG TO HL
        WEGL0(I) = WEGH(I)-Q1000(I)*R1
C  WEGU: PATH-LENGTH FROM HU TO TROPOS
        WEGU(I) = Q1000(I)*R2
  10    CONTINUE
      GO TO 13
C
  31  DO 12 I=1,M
        FA(I) = F(TA(I))
        FF(I) = FA(I)
        WEGH(I) = WEGH(I)*QRED(I)
        HL(I) = HL(I)+BERG(I)
        IF (HL(I) .GT. TROPOS(I)-0.05) THEN
          HL(I) = TROPOS(I)-0.05
          HU(I) = TROPOS(I)
          GO TO 14
        END IF
        HU(I) = DICKE(I)+HL(I)
        IF(HU(I).GT.TROPOS(I)) THEN
          HU(I) = TROPOS(I)
          GO TO 14
        ELSE
          WEGUB(I) = WEGUB(I)*QRED(I)
          WEGL0(I) = WEGL0(I)*QRED(I)
          WEGU(I) = WEGU(I)*QRED(I)
        END IF
        GO TO 15
  14    CONTINUE
        R1 = QHOEH(HL(I))
        R2 = QHOEH(HU(I))
        WEGUB(I) = Q1000(I)*(R1-R2)
        WEGL0(I) = WEGH(I)-Q1000(I)*R1
        WEGU(I) = Q1000(I)*R2
  15    WEGCLL(I)=WEGUB(I)
  12  CONTINUE
C
C
C
C  SHORTWAVE
  13  DO 20 I=1,M
C  ALBEDO CLOUDS (ACLOUD)
        IF(WEGUB(I).GT.0.0D0) THEN
          ACLOUD = 1.0D0-DEXP(-ALF2*WEGUB(I)**WOLK1/ZKK(I))
C         ACLOUD = 1.0D0-DEXP(-ALF2*CLOUDW/ZKK(I))
        ELSE
C          WRITE(*,*) 'STRAHL, I',I,WEGUB(I)
C          STOP 'STOP 11'
         FALL=11.
         RETURN
        END IF
C  ABSORPTION KURZWELLIG (KAPPA)
        QR = 0.005*WEGH(I)/(1.0D0+0.01*WEGH(I))
        KAPPA1 = KAP1+QR
        KAPPA2 = KAP2+QR
        KAPPA(I) = KAPPA1*(1-BEW(I))+KAPPA2*BEW(I)
C  DURCHLAESSIGKEIT (TRANS)
        TRANS = 1.0D0-KAPPA1-ALF1
C  ABSORPTION ATMOS (A) UND BODEN (S)
        BQ = 1.0-ALF1*ASS(I)
        ACLEAR = 1.0-ALF1-(TRANS**2*ASS(I)+TRANS*(1.0-ASS(I))/BQ)
        SCLEAR = TRANS*(1-ASS(I))/BQ
        TRANS = 1.0-KAPPA2-ACLOUD
        BQ = 1.0-ACLOUD*ASS(I)
        ACLOUDY = 1.0-ACLOUD-(TRANS**2*ASS(I)+TRANS*(1.0-ASS(I))/BQ)
        SCLOUDY = TRANS*(1-ASS(I))/BQ
C
        ABSA(I) = (1.0-BEW(I))*ACLEAR+BEW(I)*ACLOUDY
        ABSO(I) = (1.0-BEW(I))*SCLEAR+BEW(I)*SCLOUDY
        ALBW(I) = ACLOUD
  20  CONTINUE
C
C LONGWAVE
      DO 21 I=1,M
        CH = 0.1*CO2*(TROPOS(I)-BERG(I))
        IF(CH.LT.0.0D0) THEN
C          WRITE(*,*) 'CH ',CH,I,TROPOS(I),BERG(I)
C          STOP 'STOP 12'
         FALL=12.
         RETURN
        END IF
        CL0 = 0.1*CO2*(HL(I)-BERG(I))
        CU = 0.1*CO2*(TROPOS(I)-HU(I))
        IF(CU.LT.0.0D0) THEN
C          WRITE(*,*) 'CU ',CU
C          STOP 'STOP 13'
         FALL=13.
         RETURN
        END IF
        TAUH = TAU(0.1*WEGH(I),CH,GAM,COHLE,1,FALL)
        TAUL0 = TAU(0.1*WEGL0(I),CL0,GAM,COHLE,2,FALL)
        TAUU = TAU(0.1*WEGU(I),CU,GAM,COHLE,3,FALL)
        ZM = TROPOS(I)*EXBETA+BERG(I)*(1.0-EXBETA)
        FAM = F(TA(I)-LAPS*ZM)
        TL = TA(I)-LAPS*HL(I)
        FL = F(TL)
        TU = TA(I)-LAPS*HU(I)
        FU = F(TU)
        ZUM = TROPOS(I)*EXBETA+HU(I)*(1.0-EXBETA)
        FUM = F(TA(I)-LAPS*ZUM)
        DOWNH= (1.0D0-TAUH)*FA(I)
        DOWNL0 = (1.0D0-TAUL0)*FA(I)
        COUNTER = DOWNH*(1.0D0-BEW(I))+(DOWNL0+TAUL0*FL)*BEW(I)
        LO(I) = COUNTER-FF(I)
C
        FENSTW = FU*TAUU
        FENSTC = TAUH*FF(I)
        UPW = FUM*(1.0D0-TAUU)
        UPC = FAM*(1.0D0-TAUH)
        CLEAR=FENSTC+UPC
        CLOUDY=FENSTW+UPW
        LG =-(1.0D0-BEW(I))*CLEAR-BEW(I)*CLOUDY
        LA(I) = LG-LO(I)
        HLS(I) = HL(I)
        HUS(I) = HU(I)
        FEEDB=CLEAR-CLOUDY
        CQUOT(I) = FEEDB/CLEAR
        CONTR(I)=TAUH
        CONTR(I+M)=WEGH(I)
        CONTR(I+2*M)=FENSTC
        CONTR(I+3*M)=FENSTW
        CONTR(I+4*M)=UPC
        CONTR(I+5*M)=UPW
   21 CONTINUE
C
      RETURN
      END
C************************************************************************
      DOUBLE PRECISION FUNCTION TAU(WASSER,CARBON,PARW,PARC,NUM,FALL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*4 FALL
      IF(CARBON.GE.0.0D0) THEN
C        C=PARC*CARBON/(1.0D0+CARBON**0.85D0)
         C=PARC*DLOG10(1.0D0+CARBON)
      ELSE
C         WRITE(*,*) 'CARBON, NUM', CARBON, NUM
C         STOP 'STOP 14'
         FALL=14.
	 TAU=0
CC    TAU=0 just set for cross-compiled C-Version. Schuetz
         RETURN 
      END IF
      IF(WASSER.GE.0.0D0) THEN
C        W=PARW*WASSER/(1.0D0+DSQRT(WASSER))
         W=PARW*WASSER**0.36
      ELSE
C         WRITE(*,*) 'WASSER, NUM', WASSER, NUM
C         STOP 'STOP 15'
         FALL=15.
	 TAU=0
CC    TAU=0 just set for cross-compiled C-Version. Schuetz
         RETURN
      END IF
      TAU=DEXP(-W-C)
      RETURN
      END
C ===
C
      SUBROUTINE MOIST(QSTO,QSTL,QSTI,QSTLI,LAMDA,EWASSER,ELAND,
     +                 P,BEW,BEWL,RH,PCRIT,SCH,Q)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(M = 180)
C
      DOUBLE PRECISION LAMDA(M)
      DIMENSION ELAND(M),EWASSER(M),QSTI(M),QSTLI(M),
     +          BEW(M),QSTL(M),P(M),Q(M),BEWL(M),
     +          RH(M),QSTO(M),PCRIT(M),SCH(M)
C
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),FI(M),XST(M),GRADC(M),SINM(M)
     +,HADK,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CL,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
      COMMON/BL12/PC(2),RMIN,RCRIT,W0,BETA,EXBETA,QRED(M)
      COMMON/STMO/WEGCLW(M),WEGCLL(M)
C
      DATA EPS2,XH/0.02D0,0.00D0/
C     PARAMETER: PC(1), RMIN, RCRIT,
C     RMIN<RCRIT<0.90
C
C     EVA UND P IN M/YEAR
C
      DO 10 I=1,M
        EV = QSTO(I)- Q(I)
        EVI = QSTI(I)- Q(I)
        EWASSER(I) = (LAMDA(I)/CP)*0.365D0*(SCH(I)*EV+
     +               (1.0D0-SCH(I))*EVI*1.135D0)
C       LAND..
        EV = QSTL(I)-Q(I)*QRED(I)
        EVI = QSTLI(I)-Q(I)*QRED(I)
        ELAND(I) = (LAMDA(I)/CP)*0.365D0*(SCH(I)*W0*EV+
     +               (1.0D0-SCH(I))*EVI*1.135D0)
C
        WEFF=1.0
        PWASSER = WEFF*PC(1)*WEGCLW(I)*BEW(I)
        PLAND = (1.0+XH*HEIGHT(I))*WEFF*PC(1)*WEGCLL(I)*BEWL(I)
        PCRIT(I) = SPRUNG(RH(I)-RCRIT,EPS2)/EPS2
C       PCRIT(I)=0.
        P(I) = FLAND(I)*PLAND+(1.0D0-FLAND(I))*PWASSER
C
   10 CONTINUE
C
      RETURN
      END
C ===
C
      SUBROUTINE LEGEND(X,J,PP)
C LEGENDRE POLYNOMIALS
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION P(0:40)
      P(0) = 1
      P(1) = X
      DO 10 I=2,J
        P(I) = ((2*I-1)*X*P(I-1)-(I-1)*P(I-2))/I
   10 CONTINUE
      PP = P(J)
      RETURN
      END
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE SUMME(N,F,WERT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(M = 180)
C
      DIMENSION F(N)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),PHI(M),XST(M),GRADC(M),SINM(M)
     +,HADKOF,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      SAVE
C
      DATA LAUF/0/
C
      IF (LAUF.EQ.0) GO TO 12
      GO TO 13
   12 SUM1 = 0
      DO 14 I=1,M
   14 SUM1 = SUM1+ZC(I)
   13 SUM2 = 0
      DO 10 I=1,M
   10 SUM2 = SUM2+ZC(I)*F(I)
      WERT = SUM2/SUM1
      LAUF=1
      RETURN
      END
C*******************************************
      SUBROUTINE SUMM(F,WERT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (L = 2*9)
C
      DIMENSION F(L),ZC(L)
      DOUBLE PRECISION LP1,LA1,LO1
      COMMON/EXPE/TO1(L),TA1(L),TS1(L),Q1(L),EVA1(L),P1(L),RH1(L),
     +FLUSSO1(L),FLUSSA1(L),FLUSSQ1(L),BEW1(L),AP1(L),RO1(L),HU1(L),
     +RA1(L),LP1(L),ABSA1(L),ABSO1(L),LA1(L),LO1(L),FLUSSG1(L),PHI(L)
      SAVE
C
      DATA LAUF/0/
C
      IF (LAUF.EQ.0) GO TO 12
      GO TO 13
   12 CONTINUE
      ATA = DATAN(1.0D0)
      PI = 4*ATA
      DO 15 I=1,L
   15 ZC(I)=DCOS(PHI(I)*PI/180.0D0)
      SUM1 = 0
      DO 14 I=1,L/2
   14 SUM1 = SUM1+ZC(I)
   13 SUM2 = 0
      DO 10 I=1,L
   10 SUM2 = SUM2+ZC(I)*F(I)
      WERT = 0.5D0*SUM2/SUM1
      LAUF=1
      RETURN
      END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE HADL(DX,XS,GRADTA,GRADC,HAD)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (M = 180)
      DIMENSION XS(M),GRADTA(M),GRADC(M),HAD(2),XST(M/2),GRA(M/2),
     +GRC(M/2)
C
      DO 10 I=1,M-1
        DIF = GRADTA(I)-GRADTA(I+1)
        IF (DIF.NE.0.) GO TO 1
   10 CONTINUE
      HAD(1) = XS(1)
      HAD(2) = XS(M)
      RETURN
    1 CONTINUE
C     SUED
      DO 70 I=1,M/2
      J=M/2+1-I
      XST(I)=XS(J)
      GRA(I)=GRADTA(J)
   70 GRC(I)=GRADC(J)
      DO 2 I=1,M/2-1
        PRU = (GRA(I)-GRC(I))*(GRA(I+1)-GRC(I+1))
        IF (PRU.GT.0.) GO TO 2
        HAD(1) = XST(I)-DX*(GRC(I)-GRA(I))/((GRA(I+1)-
     +  GRA(I))-(GRC(I+1)-GRC(I)))
        GO TO 4
    2 CONTINUE
C
      HAD(1) = XS(1)
    4 CONTINUE
C     NORD
      DO 71 I=1,M/2
      J=M/2+I
      XST(I)=XS(J)
      GRC(I)=GRADC(J)
   71 GRA(I)=GRADTA(J)
      DO 3 I=1,M/2-1
        PRU = (GRA(I)-GRC(I))*(GRA(I+1)-GRC(I+1))
        IF (PRU.GT.0.) GO TO 3
        HAD(2) = XST(I)+DX*(GRC(I)-GRA(I))/((GRA(I+1)-
     +  GRA(I))-(GRC(I+1)-GRC(I)))
        GO TO 5
    3 CONTINUE
      HAD(2) = XS(M)
    5 RETURN
      END
C**********************************************8
C
      SUBROUTINE EISLI(TS,EISL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(M = 180)
      DIMENSION TS(M),EISL(2)
      COMMON/BL3/DX,ZC(M),ZS(M),COSM(M),PHI(M),XST(M),GRADC(M),SINM(M)
     +,HADKOF,GRCZW(M),FLAND(M),HEIGHT(M),XLAND(M),XHEIGHT(M)
      COMMON/BL11/CA,CO,CQ,CP,AL,FOK,ATA,PI,COFDA,COFDO,
     +COFDQ,COF,CI,CL,TF,TANF,TEND,RE,COFAT,COFOZ,COFFE
C
C
      DO 10 I=1,M-1
        DIF = TS(I)-TS(I+1)
        IF (DIF.NE.0.) GO TO 1
   10 CONTINUE
      IF (TS(M/2).LT.TF) THEN
        EISL(1) = 0.0D0
        EISL(2) = 0.0D0
      ELSE
        EISL(1) = -90.0D0
        EISL(2) =  90.0D0
      END IF
      RETURN
    1 CONTINUE
      DO 47 I=1,M/2-1
        PRU = (TS(I)-TF)*(TS(I+1)-TF)
        IF (PRU.GT.0.) GO TO 47
        XS = XST(I)+DX*(TF-TS(I))/(TS(I+1)-TS(I))
        GO TO 50
   47 CONTINUE
      IF (TS(M/2-1).LT.TF) EISL(1) = 0.0D0
      IF (TS(1).GE.TF) EISL(1) = -90.0D0
      GO TO 52
   50 EISL(1) = XS*180.0D0/PI
   52 CONTINUE
      DO 49 I=M/2,M-1
        PRU = (TS(I)-TF)*(TS(I+1)-TF)
        IF (PRU.GT.0.) GO TO 49
        XS = XST(I)+DX*(TF-TS(I))/(TS(I+1)-TS(I))
        GO TO 48
   49 CONTINUE
      IF (TS(M/2+1).LT.TF) EISL(2) = 0.0D0
      IF (TS(M).GE.TF) EISL(1) = 90.0D0
      RETURN
   48 EISL(2) = XS*180.0D0/PI
      RETURN
      END
C ***************************************
      DOUBLE PRECISION FUNCTION SUMP(X,EPS,X0,X1)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DATA A,B/0.0D0,1.0D0/
C
      IF (X.GT.X1+EPS) THEN
        SUMP = B
        RETURN
      END IF
      IF (X.LT.X0-EPS) THEN
        SUMP = A
        RETURN
      END IF
      R1 = SPRUNG(X-X0,EPS)
      R2 = SPRUNG(X-X1,EPS)
      SUMP = A+((B-A)/(X1-X0))*(R1-R2)
      RETURN
      END
C ***************************************
      DOUBLE PRECISION FUNCTION SPRUNG(X,EPS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      IF (X.LT.-EPS) GO TO 1
      IF (X.GT.EPS) GO TO 2
      SPRUNG = (X+EPS)**3*(3*EPS-X)/(16*EPS**3)
      RETURN
    1 SPRUNG = 0
      RETURN
    2 SPRUNG = X
      RETURN
      END
C**********************************************
C
C   IMSL ROUTINE NAME   - VBLA=DCOPY
C
C-----------------------------------------------------------------------
C
C   COMPUTER            - IBM/DOUBLE
C
C   LATEST REVISION     - JANUARY 1, 1978
C
C   PURPOSE             - COPY A VECTOR X TO A VECTOR Y, BOTH
C                           DOUBLE PRECISION
C
C   USAGE               - CALL DCOPY (N,DX,INCX,DY,INCY)
C
C   ARGUMENTS    N      - LENGTH OF VECTORS X AND Y. (INPUT)
C                DX     - DOUBLE PRECISION VECTOR OF LENGTH
C                           MAX(N*IABS(INCX),1). (INPUT)
C                INCX   - DISPLACEMENT BETWEEN ELEMENTS OF DX. (INPUT)
C                           X(I) IS DEFINED TO BE..
C                           DX(1+(I-1)*INCX) IF INCX.GE.0 OR
C                           DX(1+(I-N)*INCX) IF INCX.LT.0.
C                DY     - DOUBLE PRECISION VECTOR OF LENGTH
C                           MAX(N*IABS(INCY),1). (OUTPUT)
C                           DCOPY COPIES X(I) TO Y(I) FOR I=1,...,N.
C                           X(I) AND Y(I) REFER TO SPECIFIC ELEMENTS
C                           OF DX AND DY, RESPECTIVELY. SEE INCX AND
C                           INCY ARGUMENT DESCRIPTIONS.
C                INCY   - DISPLACEMENT BETWEEN ELEMENTS OF DY. (INPUT)
C                           Y(I) IS DEFINED TO BE..
C                           DY(1+(I-1)*INCY) IF INCY.GE.0 OR
C                           DY(1+(I-N)*INCY) IF INCY.LT.0.
C
C   PRECISION/HARDWARE  - DOUBLE/ALL
C
C   REQD. IMSL ROUTINES - NONE REQUIRED
C
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP
C
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.
C
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.
C
C-----------------------------------------------------------------------
C
      SUBROUTINE DCOPY  (N,DX,INCX,DY,INCY)
C
C                                  SPECIFICATIONS FOR ARGUMENTS
      DOUBLE PRECISION   DX(1),DY(1)
      INTEGER            N,INCX,INCY
C                                  SPECIFICATIONS FOR LOCAL VARIABLES
      INTEGER            I,IY,M,MP1,NS,IX
C                                  FIRST EXECUTABLE STATEMENT
      IF (N.LE.0) RETURN
      IF (INCX.EQ.INCY) IF (INCX-1) 5,15,35
    5 CONTINUE
C                                  CODE FOR UNEQUAL OR NONPOSITIVE
C                                    INCREMENTS.
      IX = 1
      IY = 1
      IF (INCX.LT.0) IX = (-N+1)*INCX+1
      IF (INCY.LT.0) IY = (-N+1)*INCY+1
      DO 10 I=1,N
         DY(IY) = DX(IX)
         IX = IX+INCX
         IY = IY+INCY
   10 CONTINUE
      RETURN
C                                  CODE FOR BOTH INCREMENTS EQUAL TO 1
C                                    CLEAN-UP LOOP SO REMAINING VECTOR
C                                    LENGTH IS A MULTIPLE OF 7.
   15 M = N-(N/7)*7
      IF (M.EQ.0) GO TO 25
      DO 20 I=1,M
         DY(I) = DX(I)
   20 CONTINUE
      IF (N.LT.7) RETURN
   25 MP1 = M+1
      DO 30 I=MP1,N,7
         DY(I) = DX(I)
         DY(I+1) = DX(I+1)
         DY(I+2) = DX(I+2)
         DY(I+3) = DX(I+3)
         DY(I+4) = DX(I+4)
         DY(I+5) = DX(I+5)
         DY(I+6) = DX(I+6)
   30 CONTINUE
      RETURN
C                                  CODE FOR EQUAL, POSITIVE, NONUNIT
C                                    INCREMENTS.
   35 CONTINUE
      NS = N*INCX
      DO 40 I=1,NS,INCX
         DY(I) = DX(I)
   40 CONTINUE
      RETURN
      END
C
C   IMSL ROUTINE NAME   - VBLA=DNRM2
C
C-----------------------------------------------------------------------
C
C   COMPUTER            - IBM/DOUBLE
C
C   LATEST REVISION     - JANUARY 1, 1978
C
C   PURPOSE             - COMPUTE THE EUCLIDEAN LENGTH OR L2 NORM
C                           OF A DOUBLE PRECISION VECTOR
C
C   USAGE               - FUNCTION DNRM2 (N,DX,INCX)
C
C   ARGUMENTS    DNRM2  - DOUBLE PRECISION SQUARE ROOT OF THE SUM FROM
C                           I=1 TO N OF X(I)**2. (OUTPUT)
C                           X(I) REFERS TO A SPECIFIC ELEMENT OF DX.
C                           SEE INCX ARGUMENT DESCRIPTION.
C                N      - LENGTH OF VECTOR X. (INPUT)
C                DX     - DOUBLE PRECISION VECTOR OF LENGTH N*INCX.
C                           (INPUT)
C                INCX   - DISPLACEMENT BETWEEN ELEMENTS OF DX. (INPUT)
C                           X(I) IS DEFINED TO BE DX(1+(I-1)*INCX).
C                           INCX MUST BE GREATER THAN ZERO.
C
C   PRECISION/HARDWARE  - DOUBLE/ALL
C
C   REQD. IMSL ROUTINES - NONE REQUIRED
C
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP
C
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.
C
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.
C
C-----------------------------------------------------------------------
C
      DOUBLE PRECISION FUNCTION DNRM2 (N,DX,INCX)
C
C                                  SPECIFICATIONS FOR ARGUMENTS
      INTEGER            N,INCX
      DOUBLE PRECISION   DX(1)
C                                  SPECIFICATIONS FOR LOCAL VARIABLES
      INTEGER            I,J,NEXT,NN
      DOUBLE PRECISION   CUTLO,CUTHI,SUM,XMAX,ZERO,ONE,HITEST
      DATA               ZERO, ONE /0.0D0, 1.0D0/
      DATA               CUTLO, CUTHI / 8.232D-11,  1.304D19 /
C                                  FIRST EXECUTABLE STATEMENT
      IF (N.GT.0) GO TO 5
      DNRM2 = ZERO
      GO TO 70
C
    5 ASSIGN 15 TO NEXT
      SUM = ZERO
      NN = N*INCX
C                                  BEGIN MAIN LOOP
      I = 1
   10 GO TO NEXT, (15,20,35,40)
   15 IF (DABS(DX(I)).GT.CUTLO) GO TO 55
      ASSIGN 20 TO NEXT
      XMAX = ZERO
C                                  PHASE 1. SUM IS ZERO
   20 IF (DX(I).EQ.ZERO) GO TO 65
      IF (DABS(DX(I)).GT.CUTLO) GO TO 55
C                                  PREPARE FOR PHASE 2.
      ASSIGN 35 TO NEXT
      GO TO 30
C                                  PREPARE FOR PHASE 4.
   25 I = J
      ASSIGN 40 TO NEXT
      SUM = (SUM/DX(I))/DX(I)
   30 XMAX = DABS(DX(I))
      GO TO 45
C                                  PHASE 2. SUM IS SMALL. SCALE TO
C                                    AVOID DESTRUCTIVE UNDERFLOW.
   35 IF (DABS(DX(I)).GT.CUTLO) GO TO 50
C                                  COMMON CODE FOR PHASES 2 AND 4. IN
C                                    PHASE 4 SUM IS LARGE. SCALE TO
C                                    AVOID OVERFLOW.
   40 IF (DABS(DX(I)).LE.XMAX) GO TO 45
      SUM = ONE+SUM*(XMAX/DX(I))**2
      XMAX = DABS(DX(I))
      GO TO 65
C
   45 SUM = SUM+(DX(I)/XMAX)**2
      GO TO 65
C                                  PREPARE FOR PHASE 3.
   50 SUM = (SUM*XMAX)*XMAX
C                                  FOR REAL OR D.P. SET HITEST =
C                                    CUTHI/N FOR COMPLEX SET HITEST =
C                                    CUTHI/(2*N)
   55 HITEST = CUTHI/FLOAT(N)
C                                  PHASE 3. SUM IS MID-RANGE. NO
C                                    SCALING.
      DO 60 J=I,NN,INCX
         IF (DABS(DX(J)).GE.HITEST) GO TO 25
   60 SUM = SUM+DX(J)**2
      DNRM2 = DSQRT(SUM)
      GO TO 70
C
   65 CONTINUE
      I = I+INCX
      IF (I.LE.NN) GO TO 10
C                                  END OF MAIN LOOP. COMPUTE SQUARE
C                                    ROOT AND ADJUST FOR SCALING.
      DNRM2 = XMAX*DSQRT(SUM)
   70 CONTINUE
      RETURN
      END
C
      SUBROUTINE DGBFA(ABD,LDA,N,ML,MU,IPVT,INFO)
      INTEGER LDA,N,ML,MU,IPVT(1),INFO
      DOUBLE PRECISION ABD(LDA,1)
C
C     DGBFA FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION.
C
C     DGBFA IS USUALLY CALLED BY DGBCO, BUT IT CAN BE CALLED
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA, N)
C                CONTAINS THE MATRIX IN BAND STORAGE.  THE COLUMNS
C                OF THE MATRIX ARE STORED IN THE COLUMNS OF  ABD  AND
C                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS
C                ML+1 THROUGH 2*ML+MU+1 OF  ABD .
C                SEE THE COMMENTS BELOW FOR DETAILS.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C                LDA MUST BE .GE. 2*ML + MU + 1 .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C                0 .LE. ML .LT. N .
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C                0 .LE. MU .LT. N .
C                MORE EFFICIENT IF  ML .LE. MU .
C     ON RETURN
C
C        ABD     AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND
C                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C
C        INFO    INTEGER
C                = 0  NORMAL VALUE.
C                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
C                     INDICATE THAT DGBSL WILL DIVIDE BY ZERO IF
C                     CALLED.  USE  RCOND  IN DGBCO FOR A RELIABLE
C                     INDICATION OF SINGULARITY.
C
C     BAND STORAGE
C
C           IF  A  IS A BAND MATRIX, THE FOLLOWING PROGRAM SEGMENT
C           WILL SET UP THE INPUT.
C
C                   ML = (BAND WIDTH BELOW THE DIAGONAL)
C                   MU = (BAND WIDTH ABOVE THE DIAGONAL)
C                   M = ML + MU + 1
C                   DO 20 J = 1, N
C                      I1 = MAX0(1, J-MU)
C                      I2 = MIN0(N, J+ML)
C                      DO 10 I = I1, I2
C                         K = I - J + M
C                         ABD(K,J) = A(I,J)
C                10    CONTINUE
C                20 CONTINUE
C
C           THIS USES ROWS  ML+1  THROUGH  2*ML+MU+1  OF  ABD .
C           IN ADDITION, THE FIRST  ML  ROWS IN  ABD  ARE USED FOR
C           ELEMENTS GENERATED DURING THE TRIANGULARIZATION.
C           THE TOTAL NUMBER OF ROWS NEEDED IN  ABD  IS  2*ML+MU+1 .
C           THE  ML+MU BY ML+MU  UPPER LEFT TRIANGLE AND THE
C           ML BY ML  LOWER RIGHT TRIANGLE ARE NOT REFERENCED.
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DSCAL,IDAMAX
C     FORTRAN MAX0,MIN0
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION T
      INTEGER I,IDAMAX,I0,J,JU,JZ,J0,J1,K,KP1,L,LM,M,MM,NM1
C
C
      M = ML + MU + 1
      INFO = 0
C
C     ZERO INITIAL FILL-IN COLUMNS
C
      J0 = MU + 2
      J1 = MIN0(N,M) - 1
      IF (J1 .LT. J0) GO TO 30
      DO 20 JZ = J0, J1
         I0 = M + 1 - JZ
         DO 10 I = I0, ML
            ABD(I,JZ) = 0.0D0
   10    CONTINUE
   20 CONTINUE
   30 CONTINUE
      JZ = J1
      JU = 0
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 130
      DO 120 K = 1, NM1
         KP1 = K + 1
C
C        ZERO NEXT FILL-IN COLUMN
C
         JZ = JZ + 1
         IF (JZ .GT. N) GO TO 50
         IF (ML .LT. 1) GO TO 50
            DO 40 I = 1, ML
               ABD(I,JZ) = 0.0D0
   40       CONTINUE
   50    CONTINUE
C
C        FIND L = PIVOT INDEX
C
         LM = MIN0(ML,N-K)
         L = IDAMAX(LM+1,ABD(M,K),1) + M - 1
         IPVT(K) = L + K - M
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF (ABD(L,K) .EQ. 0.0D0) GO TO 100
C
C           INTERCHANGE IF NECESSARY
C
            IF (L .EQ. M) GO TO 60
               T = ABD(L,K)
               ABD(L,K) = ABD(M,K)
               ABD(M,K) = T
   60       CONTINUE
C
C           COMPUTE MULTIPLIERS
C
            T = -1.0D0/ABD(M,K)
            CALL DSCAL(LM,T,ABD(M+1,K),1)
C
C           ROW ELIMINATION WITH COLUMN INDEXING
C
            JU = MIN0(MAX0(JU,MU+IPVT(K)),N)
            MM = M
            IF (JU .LT. KP1) GO TO 90
            DO 80 J = KP1, JU
               L = L - 1
               MM = MM - 1
               T = ABD(L,J)
               IF (L .EQ. MM) GO TO 70
                  ABD(L,J) = ABD(MM,J)
                  ABD(MM,J) = T
   70          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,ABD(MM+1,J),1)
   80       CONTINUE
   90       CONTINUE
         GO TO 110
  100    CONTINUE
            INFO = K
  110    CONTINUE
  120 CONTINUE
  130 CONTINUE
      IPVT(N) = N
      IF (ABD(M,N) .EQ. 0.0D0) INFO = N
      RETURN
      END
C
      SUBROUTINE DGBSL(ABD,LDA,N,ML,MU,IPVT,B,JOB)
      INTEGER LDA,N,ML,MU,IPVT(1),JOB
      DOUBLE PRECISION ABD(LDA,1),B(1)
C
C     DGBSL SOLVES THE DOUBLE PRECISION BAND SYSTEM
C     A * X = B  OR  TRANS(A) * X = B
C     USING THE FACTORS COMPUTED BY DGBCO OR DGBFA.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA, N)
C                THE OUTPUT FROM DGBCO OR DGBFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGBCO OR DGBFA.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C        JOB     INTEGER
C                = 0         TO SOLVE  A*X = B ,
C                = NONZERO   TO SOLVE  TRANS(A)*X = B , WHERE
C                            TRANS(A)  IS THE TRANSPOSE.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGBCO HAS SET RCOND .GT. 0.0
C        OR DGBFA HAS SET INFO .EQ. 0 .
C
C     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
C           IF (RCOND IS TOO SMALL) GO TO ...
C           DO 10 J = 1, P
C              CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
C        10 CONTINUE
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C     FORTRAN MIN0
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION DDOT,T
      INTEGER K,KB,L,LA,LB,LM,M,NM1
C
      M = MU + ML + 1
      NM1 = N - 1
      IF (JOB .NE. 0) GO TO 50
C
C        JOB = 0 , SOLVE  A * X = B
C        FIRST SOLVE L*Y = B
C
         IF (ML .EQ. 0) GO TO 30
         IF (NM1 .LT. 1) GO TO 30
            DO 20 K = 1, NM1
               LM = MIN0(ML,N-K)
               L = IPVT(K)
               T = B(L)
               IF (L .EQ. K) GO TO 10
                  B(L) = B(K)
                  B(K) = T
   10          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,B(K+1),1)
   20       CONTINUE
   30    CONTINUE
C
C        NOW SOLVE  U*X = Y
C
         DO 40 KB = 1, N
            K = N + 1 - KB
            B(K) = B(K)/ABD(M,K)
            LM = MIN0(K,M) - 1
            LA = M - LM
            LB = K - LM
            T = -B(K)
            CALL DAXPY(LM,T,ABD(LA,K),1,B(LB),1)
   40    CONTINUE
      GO TO 100
   50 CONTINUE
C
C        JOB = NONZERO, SOLVE  TRANS(A) * X = B
C        FIRST SOLVE  TRANS(U)*Y = B
C
         DO 60 K = 1, N
            LM = MIN0(K,M) - 1
            LA = M - LM
            LB = K - LM
            T = DDOT(LM,ABD(LA,K),1,B(LB),1)
            B(K) = (B(K) - T)/ABD(M,K)
   60    CONTINUE
C
C        NOW SOLVE TRANS(L)*X = Y
C
         IF (ML .EQ. 0) GO TO 90
         IF (NM1 .LT. 1) GO TO 90
            DO 80 KB = 1, NM1
               K = N - KB
               LM = MIN0(ML,N-K)
               B(K) = B(K) + DDOT(LM,ABD(M+1,K),1,B(K+1),1)
               L = IPVT(K)
               IF (L .EQ. K) GO TO 70
                  T = B(L)
                  B(L) = B(K)
                  B(K) = T
   70          CONTINUE
   80       CONTINUE
   90    CONTINUE
  100 CONTINUE
      RETURN
      END
C
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
C
C     CONSTANT TIMES A VECTOR PLUS A VECTOR.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C     MODIFIED 12/3/93, ARRAY(1) DECLARATIONS CHANGED TO ARRAY(*)
C
      DOUBLE PRECISION DX(*),DY(*),DA
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      IF(N.LE.0)RETURN
      IF (DA .EQ. 0.0D0) RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DY(IY) + DA*DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DY(I) + DA*DX(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        DY(I) = DY(I) + DA*DX(I)
        DY(I + 1) = DY(I + 1) + DA*DX(I + 1)
        DY(I + 2) = DY(I + 2) + DA*DX(I + 2)
        DY(I + 3) = DY(I + 3) + DA*DX(I + 3)
   50 CONTINUE
      RETURN
      END
C
      INTEGER FUNCTION IDAMAX(N,DX,INCX)
C
C     FINDS THE INDEX OF ELEMENT HAVING MAX. ABSOLUTE VALUE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C     MODIFIED 3/93 TO RETURN IF INCX .LE. 0.
C     MODIFIED 12/3/93, ARRAY(1) DECLARATIONS CHANGED TO ARRAY(*)
C
      DOUBLE PRECISION DX(*),DMAX
      INTEGER I,INCX,IX,N
C
      IDAMAX = 0
      IF( N.LT.1 .OR. INCX.LE.0 ) RETURN
      IDAMAX = 1
      IF(N.EQ.1)RETURN
      IF(INCX.EQ.1)GO TO 20
C
C        CODE FOR INCREMENT NOT EQUAL TO 1
C
      IX = 1
      DMAX = DABS(DX(1))
      IX = IX + INCX
      DO 10 I = 2,N
         IF(DABS(DX(IX)).LE.DMAX) GO TO 5
         IDAMAX = I
         DMAX = DABS(DX(IX))
    5    IX = IX + INCX
   10 CONTINUE
      RETURN
C
C        CODE FOR INCREMENT EQUAL TO 1
C
   20 DMAX = DABS(DX(1))
      DO 30 I = 2,N
         IF(DABS(DX(I)).LE.DMAX) GO TO 30
         IDAMAX = I
         DMAX = DABS(DX(I))
   30 CONTINUE
      RETURN
      END
C
      SUBROUTINE  DSCAL(N,DA,DX,INCX)
C
C     SCALES A VECTOR BY A CONSTANT.
C     USES UNROLLED LOOPS FOR INCREMENT EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C     MODIFIED 3/93 TO RETURN IF INCX .LE. 0.
C     MODIFIED 12/3/93, ARRAY(1) DECLARATIONS CHANGED TO ARRAY(*)
C
      DOUBLE PRECISION DA,DX(*)
      INTEGER I,INCX,M,MP1,N,NINCX
C
      IF( N.LE.0 .OR. INCX.LE.0 )RETURN
      IF(INCX.EQ.1)GO TO 20
C
C        CODE FOR INCREMENT NOT EQUAL TO 1
C
      NINCX = N*INCX
      DO 10 I = 1,NINCX,INCX
        DX(I) = DA*DX(I)
   10 CONTINUE
      RETURN
C
C        CODE FOR INCREMENT EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DX(I) = DA*DX(I)
   30 CONTINUE
      IF( N .LT. 5 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DX(I) = DA*DX(I)
        DX(I + 1) = DA*DX(I + 1)
        DX(I + 2) = DA*DX(I + 2)
        DX(I + 3) = DA*DX(I + 3)
        DX(I + 4) = DA*DX(I + 4)
   50 CONTINUE
      RETURN
      END
C
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
C
C     FORMS THE DOT PRODUCT OF TWO VECTORS.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C     MODIFIED 12/3/93, ARRAY(1) DECLARATIONS CHANGED TO ARRAY(*)
C
      DOUBLE PRECISION DX(*),DY(*),DTEMP
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      DDOT = 0.0D0
      DTEMP = 0.0D0
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = DTEMP + DX(IX)*DY(IY)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      DDOT = DTEMP
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DTEMP = DTEMP + DX(I)*DY(I)
   30 CONTINUE
      IF( N .LT. 5 ) GO TO 60
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DTEMP = DTEMP + DX(I)*DY(I) + DX(I + 1)*DY(I + 1) +
     *   DX(I + 2)*DY(I + 2) + DX(I + 3)*DY(I + 3) + DX(I + 4)*DY(I + 4)
   50 CONTINUE
   60 DDOT = DTEMP
      RETURN
      END
